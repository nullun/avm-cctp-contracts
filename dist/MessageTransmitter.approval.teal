#pragma version 10

// This TEAL was generated by TEALScript v0.72.1
// https://github.com/algorandfoundation/TEALScript

// This contract is compliant with and/or implements the following ARCs: [ ARC4 ]

// The following ten lines of TEAL handle initial program flow
// This pattern is used to make it easy for anyone to parse the start of the program and determine if a specific action is allowed
// Here, action refers to the OnComplete in combination with whether the app is being created or called
// Every possible action for this contract is represented in the switch statement
// If the action is not implmented in the contract, its respective branch will be "NOT_IMPLEMENTED" which just contains "err"
txn ApplicationID
!
int 6
*
txn OnCompletion
+
switch call_NoOp NOT_IMPLEMENTED NOT_IMPLEMENTED NOT_IMPLEMENTED NOT_IMPLEMENTED NOT_IMPLEMENTED create_NoOp NOT_IMPLEMENTED NOT_IMPLEMENTED NOT_IMPLEMENTED NOT_IMPLEMENTED NOT_IMPLEMENTED

NOT_IMPLEMENTED:
	err

// onlyOwner()void
//
// @dev Throws if called by any account other than the owner.
onlyOwner:
	proto 0 0

	// src/MessageTransmitter.algo.ts:135
	// assert(this.txn.sender === this.owner.value)
	txn Sender
	byte 0x6f776e6572 // "owner"
	app_global_get
	==
	assert
	retsub

// onlyAttesterManager()void
//
// @dev Throws if called by any account other than the attester manager.
onlyAttesterManager:
	proto 0 0

	// src/MessageTransmitter.algo.ts:142
	// assert(this.txn.sender === this.attesterManager.value)
	txn Sender
	byte 0x61747465737465724d616e61676572 // "attesterManager"
	app_global_get
	==
	assert
	retsub

// _transferOwnership(address)void
//
// @dev Transfers ownership of the application to a new account (`newOwner`).
// Internal function without access restriction.
_transferOwnership:
	proto 1 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// src/MessageTransmitter.algo.ts:153
	// oldOwner: Address = this.owner.exists ? this.owner.value : globals.zeroAddress
	txna Applications 0
	byte 0x6f776e6572 // "owner"
	app_global_get_ex
	swap
	pop
	bz ternary1_false
	byte 0x6f776e6572 // "owner"
	app_global_get
	b ternary1_end

ternary1_false:
	global ZeroAddress

ternary1_end:
	frame_bury 0 // oldOwner: Address

	// src/MessageTransmitter.algo.ts:154
	// this.owner.value = newOwner
	byte 0x6f776e6572 // "owner"
	frame_dig -1 // newOwner: Address
	app_global_put

	// src/MessageTransmitter.algo.ts:156
	// this.OwnershipTransferred.log({ oldAddress: oldOwner, newAddress: newOwner })
	byte 0x9a223efb // OwnershipTransferred(address,address)
	frame_dig 0 // oldOwner: Address
	frame_dig -1 // newOwner: Address
	concat
	concat
	log
	retsub

// _setAttesterManager(address)void
//
// @dev Sets a new attester manager address
// @param _newAttesterManager attester manager address to set
_setAttesterManager:
	proto 1 0

	// src/MessageTransmitter.algo.ts:165
	// this.attesterManager.value = _newAttesterManager
	byte 0x61747465737465724d616e61676572 // "attesterManager"
	frame_dig -1 // _newAttesterManager: Address
	app_global_put
	retsub

// _isEnabledAttester(byte[32])bool
//
// @notice returns true if given `attester` is enabled, else false
// @param attester attester to check enabled status of
// @return true if given `attester` is enabled, else false
_isEnabledAttester:
	proto 1 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 3

	// src/MessageTransmitter.algo.ts:175
	// assert(attester != bzero(32) as bytes32)
	frame_dig -1 // attester: bytes32
	byte 0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
	byte 0x
	dup
	b==
	assert
	extract 0 32
	!=
	assert

	// src/MessageTransmitter.algo.ts:177
	// boxSize = this.enabledAttesters.size - 2
	byte 0x656e61626c6564417474657374657273 // "enabledAttesters"
	box_len
	assert
	int 2
	-
	frame_bury 0 // boxSize: uint64

	// if0_condition
	// src/MessageTransmitter.algo.ts:178
	// boxSize > 0
	frame_dig 0 // boxSize: uint64
	int 0
	>
	bz if0_end

	// if0_consequent
	// src/MessageTransmitter.algo.ts:179
	// numAttesters = boxSize / 32
	frame_dig 0 // boxSize: uint64
	int 32
	/
	frame_bury 1 // numAttesters: uint64

	// src/MessageTransmitter.algo.ts:180
	// index = 0
	int 0
	frame_bury 2 // index: uint64

while_0:
	// src/MessageTransmitter.algo.ts:181
	// index < numAttesters
	frame_dig 2 // index: uint64
	frame_dig 1 // numAttesters: uint64
	<
	bz while_0_end

	// if1_condition
	// src/MessageTransmitter.algo.ts:182
	// attester == this.enabledAttesters.value[index]
	frame_dig -1 // attester: bytes32
	byte 0x656e61626c6564417474657374657273 // "enabledAttesters"
	box_get
	assert
	extract 2 0
	store 255 // full array
	int 0 // initial offset
	frame_dig 2 // index: uint64
	int 32
	* // acc * typeLength
	+
	load 255 // full array
	swap
	int 32
	extract3
	==
	bz if1_end

	// if1_consequent
	// src/MessageTransmitter.algo.ts:183
	// return true;
	int 1

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 2
	retsub

if1_end:
	// src/MessageTransmitter.algo.ts:185
	// index = index + 1
	frame_dig 2 // index: uint64
	int 1
	+
	frame_bury 2 // index: uint64
	b while_0

while_0_end:

if0_end:
	// src/MessageTransmitter.algo.ts:189
	// return false;
	int 0

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 2
	retsub

// _recoverAttesterSignature((byte[32],byte[32],uint8),byte[32])byte[32]
//
// @notice Checks that signature was signed by attester
// @param _digest message hash
// @param _signature message signature
// @return address of recovered signer
_recoverAttesterSignature:
	proto 2 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 5

	// src/MessageTransmitter.algo.ts:202
	// r = btobigint(_signature.r)
	frame_dig -2 // _signature: Signature
	extract 0 32
	frame_bury 0 // r: bigint

	// src/MessageTransmitter.algo.ts:203
	// s = btobigint(_signature.s)
	frame_dig -2 // _signature: Signature
	extract 32 32
	frame_bury 1 // s: bigint

	// src/MessageTransmitter.algo.ts:204
	// v = _signature.v - 27
	frame_dig -2 // _signature: Signature
	extract 64 1
	btoi
	int 27
	-
	frame_bury 2 // v: unsafe uint8

	// src/MessageTransmitter.algo.ts:206
	// res = ecdsa_pk_recover("Secp256k1", _digest, <uint64>v, r, s)
	frame_dig -1 // _digest: bytes32
	frame_dig 2 // v: unsafe uint8
	frame_dig 0 // r: bigint
	frame_dig 1 // s: bigint
	ecdsa_pk_recover Secp256k1
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	swap
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	swap
	concat
	frame_bury 3 // res: (uint256,uint256)

	// src/MessageTransmitter.algo.ts:207
	// addr = bzero(12) + substring3(keccak256(rawBytes(res)), 12, 32) as bytes32
	byte 0x000000000000000000000000
	frame_dig 3 // res: (uint256,uint256)
	keccak256
	substring 12 32
	concat
	byte 0x0000000000000000000000000000000000000000000000000000000000000000
	concat
	dup
	extract 32 0
	byte 0x
	b==
	assert
	extract 0 32
	frame_bury 4 // addr: byte[32]

	// src/MessageTransmitter.algo.ts:209
	// return addr
	frame_dig 4 // addr: byte[32]

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 4
	retsub

// _verifyAttestationSignatures(byte[],byte[])void
//
// @notice reverts if the attestation, which is comprised of one or more concatenated 65-byte signatures, is invalid.
// @dev Rules for valid attestation:
// 1. length of `_attestation` == 65 (signature length) * signatureThreshold
// 2. addresses recovered from attestation must be in increasing order.
// For example, if signature A is signed by address 0x1..., and signature B
// is signed by address 0x2..., attestation must be passed as AB.
// 3. no duplicate signers
// 4. all signers must be enabled attesters
//
// Based on Christian Lundkvist's Simple Multisig
// (https://github.com/christianlundkvist/simple-multisig/tree/560c463c8651e0a4da331bd8f245ccd2a48ab63d)
// @param _message message to verify attestation of
// @param _attestation attestation of `_message`
_verifyAttestationSignatures:
	proto 2 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 6

	// src/MessageTransmitter.algo.ts:231
	// assert(_attestation.length === signatureLength * this.signatureThreshold.value)
	frame_dig -2 // _attestation: bytes
	len
	int 65
	byte 0x7369676e61747572655468726573686f6c64 // "signatureThreshold"
	app_global_get
	*
	==
	assert

	// src/MessageTransmitter.algo.ts:235
	// _latestAttesterAddress: bytes32 = bzero(32) as bytes32
	byte 0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
	byte 0x
	dup
	b==
	assert
	extract 0 32
	frame_bury 0 // _latestAttesterAddress: bytes32

	// src/MessageTransmitter.algo.ts:237
	// _signatures = castBytes<Signature[]>(_attestation)
	frame_dig -2 // _attestation: bytes
	frame_bury 1 // _signatures: (byte[32],byte[32],uint8)[]

	// src/MessageTransmitter.algo.ts:238
	// _digest = keccak256(_message)
	frame_dig -1 // _message: bytes
	keccak256
	frame_bury 2 // _digest: byte[32]

	// src/MessageTransmitter.algo.ts:239
	// i = 0
	int 0
	frame_bury 3 // i: uint64

for_0:
	// src/MessageTransmitter.algo.ts:239
	// i < this.signatureThreshold.value
	frame_dig 3 // i: uint64
	byte 0x7369676e61747572655468726573686f6c64 // "signatureThreshold"
	app_global_get
	<
	bz for_0_end
	frame_dig 3 // i: uint64
	frame_bury 4 // accessor: accessor//0//_signature

while_1:
	// src/MessageTransmitter.algo.ts:243
	// globals.opcodeBudget < 2500
	global OpcodeBudget
	int 2500
	<
	bz while_1_end

	// src/MessageTransmitter.algo.ts:244
	// sendAppCall({
	// 					onCompletion: OnCompletion.DeleteApplication,
	// 					approvalProgram: hex("0x0a8101"),
	// 					clearStateProgram: hex("0x0a8101")
	// 				})
	itxn_begin
	int appl
	itxn_field TypeEnum

	// src/MessageTransmitter.algo.ts:245
	// onCompletion: OnCompletion.DeleteApplication
	int 5 // DeleteApplication
	itxn_field OnCompletion

	// src/MessageTransmitter.algo.ts:246
	// approvalProgram: hex("0x0a8101")
	byte 0x0a8101
	itxn_field ApprovalProgram

	// src/MessageTransmitter.algo.ts:247
	// clearStateProgram: hex("0x0a8101")
	byte 0x0a8101
	itxn_field ClearStateProgram

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	b while_1

while_1_end:
	// src/MessageTransmitter.algo.ts:252
	// _recoveredAttester: bytes32 = this._recoverAttesterSignature(
	// 				_digest,
	// 				_signature
	// 			)
	frame_dig 1 // _signatures: (byte[32],byte[32],uint8)[]
	store 255 // full array
	int 0 // initial offset
	frame_dig 4 // saved accessor: accessor//0//_signature
	int 65
	* // acc * typeLength
	+
	load 255 // full array
	swap
	int 65
	extract3
	frame_dig 2 // _digest: byte[32]
	callsub _recoverAttesterSignature
	frame_bury 5 // _recoveredAttester: bytes32

	// src/MessageTransmitter.algo.ts:258
	// assert(btobigint(_recoveredAttester) > btobigint(_latestAttesterAddress))
	frame_dig 5 // _recoveredAttester: bytes32
	frame_dig 0 // _latestAttesterAddress: bytes32
	b>
	assert

	// src/MessageTransmitter.algo.ts:259
	// assert(this._isEnabledAttester(_recoveredAttester))
	frame_dig 5 // _recoveredAttester: bytes32
	callsub _isEnabledAttester
	assert

	// src/MessageTransmitter.algo.ts:261
	// _latestAttesterAddress = _recoveredAttester
	frame_dig 5 // _recoveredAttester: bytes32
	frame_bury 0 // _latestAttesterAddress: bytes32

	// src/MessageTransmitter.algo.ts:239
	// i = i + 1
	frame_dig 3 // i: uint64
	int 1
	+
	frame_bury 3 // i: uint64
	b for_0

for_0_end:
	retsub

// _reserveAndIncrementNonce()uint64
//
// Reserve and increment next available nonce
// @return nonce reserved
_reserveAndIncrementNonce:
	proto 0 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// src/MessageTransmitter.algo.ts:272
	// _nonceReserved: uint<64> = this.nextAvailableNonce.value
	byte 0x6e657874417661696c61626c654e6f6e6365 // "nextAvailableNonce"
	app_global_get
	frame_bury 0 // _nonceReserved: uint<64>

	// src/MessageTransmitter.algo.ts:273
	// this.nextAvailableNonce.value = this.nextAvailableNonce.value + 1
	byte 0x6e657874417661696c61626c654e6f6e6365 // "nextAvailableNonce"
	dup
	app_global_get
	int 1
	+
	app_global_put

	// src/MessageTransmitter.algo.ts:275
	// return _nonceReserved;
	frame_dig 0 // _nonceReserved: uint<64>

	// set the subroutine return value
	frame_bury 0
	retsub

// _sendMessage(byte[],uint64,byte[32],byte[32],byte[32],uint32)void
//
// @notice Send the message to the destination domain and recipient. If `_destinationCaller` is not equal to bytes32(0),
// the message can only be received on the destination chain when called by `_destinationCaller`.
// @dev Format the message and emit `MessageSent` event with message information.
// @param _destinationDomain Domain of destination chain
// @param _recipient Address of message recipient on destination domain as bytes32
// @param _destinationCaller caller on the destination domain, as bytes32
// @param _sender message sender, as bytes32
// @param _nonce nonce reserved for message
// @param _messageBody Raw bytes content of message
_sendMessage:
	proto 6 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// src/MessageTransmitter.algo.ts:297
	// assert(_messageBody.length <= this.maxMessageBodySize.value)
	frame_dig -6 // _messageBody: bytes
	len
	byte 0x6d61784d657373616765426f647953697a65 // "maxMessageBodySize"
	app_global_get
	<=
	assert

	// src/MessageTransmitter.algo.ts:298
	// assert(_recipient != bzero(32) as bytes32)
	frame_dig -2 // _recipient: bytes32
	byte 0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
	byte 0x
	dup
	b==
	assert
	extract 0 32
	!=
	assert

	// src/MessageTransmitter.algo.ts:301
	// _message: Message = {
	// 			_msgVersion: this.version.value,
	// 			_msgSourceDomain: this.localDomain.value,
	// 			_msgDestinationDomain: _destinationDomain,
	// 			_msgNonce: _nonce,
	// 			_msgSender: _sender,
	// 			_msgRecipient: _recipient,
	// 			_msgDestinationCaller: _destinationCaller,
	// 			//_msgRawBody: _messageBody
	// 		}
	byte 0x76657273696f6e // "version"
	app_global_get
	btoi
	itob
	extract 4 4
	byte 0x6c6f63616c446f6d61696e // "localDomain"
	app_global_get
	btoi
	itob
	extract 4 4
	concat
	frame_dig -1 // _destinationDomain: uint<32>
	itob
	extract 4 4
	concat
	frame_dig -5 // _nonce: uint<64>
	itob
	concat
	frame_dig -4 // _sender: bytes32
	concat
	frame_dig -2 // _recipient: bytes32
	concat
	frame_dig -3 // _destinationCaller: bytes32
	concat
	frame_bury 0 // _message: Message

	// src/MessageTransmitter.algo.ts:312
	// this.MessageSent.log({ message: rawBytes(_message) + _messageBody })
	byte 0x42a65f80 // MessageSent(byte[])
	byte 0x // initial head
	byte 0x // initial tail
	byte 0x0002 // initial head offset
	frame_dig 0 // _message: Message
	frame_dig -6 // _messageBody: bytes
	concat
	dup
	len
	itob
	extract 6 2
	swap
	concat
	callsub process_dynamic_tuple_element
	pop // pop head offset
	concat // concat head and tail
	concat
	log
	retsub

// _validateMessageFormat((uint32,uint32,uint32,uint64,byte[32],byte[32],byte[32]))void
//
// @dev The message body is dynamically-sized to support custom message body
// formats. Other fields must be fixed-size to avoid hash collisions.
// Each other input value has an explicit type to guarantee fixed-size.
// Padding: uintNN fields are left-padded, and bytesNN fields are right-padded.
//
// Field                 Bytes      Type       Index
// version               4          uint32     0
// sourceDomain          4          uint32     4
// destinationDomain     4          uint32     8
// nonce                 8          uint64     12
// sender                32         bytes32    20
// recipient             32         bytes32    52
// destinationCaller     32         bytes32    84
// messageBody           dynamic    bytes      116
//
// @notice Reverts if message is incorrect length
// @param _message The message
_validateMessageFormat:
	proto 1 0

	// src/MessageTransmitter.algo.ts:335
	// assert(rawBytes(_message).length >= 116)
	frame_dig -1 // _message: Message
	len
	int 116
	>=
	assert
	retsub

abi_route_transferOwnership:
	// newOwner: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// execute transferOwnership(address)void
	callsub transferOwnership
	int 1
	return

// transferOwnership(address)void
//
// @dev Transfers ownership of the application to a new account (`newOwner`).
// Can only be called by the current owner.
transferOwnership:
	proto 1 0

	// src/MessageTransmitter.algo.ts:346
	// this.onlyOwner()
	callsub onlyOwner

	// src/MessageTransmitter.algo.ts:348
	// assert(newOwner != globals.zeroAddress)
	frame_dig -1 // newOwner: Address
	global ZeroAddress
	!=
	assert

	// src/MessageTransmitter.algo.ts:350
	// this._transferOwnership(newOwner)
	frame_dig -1 // newOwner: Address
	callsub _transferOwnership
	retsub

abi_route_enableAttester:
	// newAttester: byte[32]
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// execute enableAttester(byte[32])void
	callsub enableAttester
	int 1
	return

// enableAttester(byte[32])void
//
// @notice Enables an attester
// @dev Only callable by attesterManager. New attester must not be attesters.
// @param newAttester attester to enable
enableAttester:
	proto 1 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// src/MessageTransmitter.algo.ts:360
	// this.onlyAttesterManager()
	callsub onlyAttesterManager

	// if2_condition
	// src/MessageTransmitter.algo.ts:363
	// !this.enabledAttesters.exists
	byte 0x656e61626c6564417474657374657273 // "enabledAttesters"
	box_len
	swap
	pop
	!
	bz if2_end

	// if2_consequent
	// src/MessageTransmitter.algo.ts:364
	// this.enabledAttesters.create(2)
	byte 0x656e61626c6564417474657374657273 // "enabledAttesters"
	int 2
	box_create

if2_end:
	// src/MessageTransmitter.algo.ts:368
	// assert(!this._isEnabledAttester(newAttester))
	frame_dig -1 // newAttester: bytes32
	callsub _isEnabledAttester
	!
	assert

	// src/MessageTransmitter.algo.ts:370
	// originalSize = this.enabledAttesters.size
	byte 0x656e61626c6564417474657374657273 // "enabledAttesters"
	box_len
	assert
	frame_bury 0 // originalSize: uint64

	// src/MessageTransmitter.algo.ts:375
	// box_resize("enabledAttesters", originalSize + 32)
	byte 0x656e61626c6564417474657374657273 // "enabledAttesters"
	frame_dig 0 // originalSize: uint64
	int 32
	+
	box_resize

	// src/MessageTransmitter.algo.ts:379
	// box_splice("enabledAttesters", originalSize, 32, newAttester)
	byte 0x656e61626c6564417474657374657273 // "enabledAttesters"
	frame_dig 0 // originalSize: uint64
	int 32
	frame_dig -1 // newAttester: bytes32
	box_splice
	retsub

abi_route_offsetOfEnabledAttester:
	// The ABI return prefix
	byte 0x151f7c75

	// attester: byte[32]
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// execute offsetOfEnabledAttester(byte[32])uint64
	callsub offsetOfEnabledAttester
	itob
	concat
	log
	int 1
	return

// offsetOfEnabledAttester(byte[32])uint64
//
// @notice returns the index of a given `attester`, else fails
// @param attester attester to retrieve index of
// @return index of given `attester`, else fails
offsetOfEnabledAttester:
	proto 1 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dup

	// src/MessageTransmitter.algo.ts:390
	// boxSize = this.enabledAttesters.size
	byte 0x656e61626c6564417474657374657273 // "enabledAttesters"
	box_len
	assert
	frame_bury 0 // boxSize: uint64

	// src/MessageTransmitter.algo.ts:391
	// i = 2
	int 2
	frame_bury 1 // i: uint64

for_1:
	// src/MessageTransmitter.algo.ts:391
	// i < boxSize
	frame_dig 1 // i: uint64
	frame_dig 0 // boxSize: uint64
	<
	bz for_1_end

	// if3_condition
	// src/MessageTransmitter.algo.ts:392
	// attester == this.enabledAttesters.value[i]
	frame_dig -1 // attester: bytes32
	byte 0x656e61626c6564417474657374657273 // "enabledAttesters"
	box_get
	assert
	extract 2 0
	store 255 // full array
	int 0 // initial offset
	frame_dig 1 // i: uint64
	int 32
	* // acc * typeLength
	+
	load 255 // full array
	swap
	int 32
	extract3
	==
	bz if3_end

	// if3_consequent
	// src/MessageTransmitter.algo.ts:393
	// return i;
	frame_dig 1 // i: uint64

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 1
	retsub

if3_end:
	// src/MessageTransmitter.algo.ts:391
	// i = i + 32
	frame_dig 1 // i: uint64
	int 32
	+
	frame_bury 1 // i: uint64
	b for_1

for_1_end:
	// src/MessageTransmitter.algo.ts:396
	// assert(0)
	int 0
	assert

	// src/MessageTransmitter.algo.ts:397
	// return 0;
	int 0

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 1
	retsub

abi_route_getNumEnabledAttesters:
	// The ABI return prefix
	byte 0x151f7c75

	// execute getNumEnabledAttesters()uint64
	callsub getNumEnabledAttesters
	itob
	concat
	log
	int 1
	return

// getNumEnabledAttesters()uint64
//
// @notice returns the number of enabled attesters
// @return number of enabled attesters
getNumEnabledAttesters:
	proto 0 1

	// src/MessageTransmitter.algo.ts:405
	// return this.enabledAttesters.size / 32;
	byte 0x656e61626c6564417474657374657273 // "enabledAttesters"
	box_len
	assert
	int 32
	/
	retsub

abi_route_updateAttesterManager:
	// newAttesterManager: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// execute updateAttesterManager(address)void
	callsub updateAttesterManager
	int 1
	return

// updateAttesterManager(address)void
//
// FIX: onlyOwner or onlyAttesterManager?
// @dev Allows the current attester manager to transfer control of the application to a newAttesterManager.
// @param newAttesterManager The address to update attester manager to.
updateAttesterManager:
	proto 1 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// src/MessageTransmitter.algo.ts:414
	// this.onlyOwner()
	callsub onlyOwner

	// src/MessageTransmitter.algo.ts:416
	// assert(newAttesterManager != globals.zeroAddress)
	frame_dig -1 // newAttesterManager: Address
	global ZeroAddress
	!=
	assert

	// src/MessageTransmitter.algo.ts:418
	// _oldAttesterManager: Address = this.attesterManager.exists ? this.attesterManager.value : globals.zeroAddress
	txna Applications 0
	byte 0x61747465737465724d616e61676572 // "attesterManager"
	app_global_get_ex
	swap
	pop
	bz ternary3_false
	byte 0x61747465737465724d616e61676572 // "attesterManager"
	app_global_get
	b ternary3_end

ternary3_false:
	global ZeroAddress

ternary3_end:
	frame_bury 0 // _oldAttesterManager: Address

	// src/MessageTransmitter.algo.ts:419
	// this._setAttesterManager(newAttesterManager)
	frame_dig -1 // newAttesterManager: Address
	callsub _setAttesterManager

	// src/MessageTransmitter.algo.ts:421
	// this.AttesterManagerUpdated.log({ previousAttesterManager: _oldAttesterManager, newAttesterManager: newAttesterManager })
	byte 0x8d199cdf // AttesterManagerUpdated(address,address)
	frame_dig 0 // _oldAttesterManager: Address
	frame_dig -1 // newAttesterManager: Address
	concat
	concat
	log
	retsub

abi_route_disableAttester:
	// attester: byte[32]
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// execute disableAttester(byte[32])void
	callsub disableAttester
	int 1
	return

// disableAttester(byte[32])void
//
// @notice Disables an attester
// @dev Only callable by attesterManager. Disabling the attester is not allowed if there is only one attester
// enabled, or if it would cause the number of enabled attesters to become less than signatureThreshold.
// (Attester must be currently enabled.)
// @param attester attester to disable
disableAttester:
	proto 1 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// src/MessageTransmitter.algo.ts:432
	// this.onlyAttesterManager()
	callsub onlyAttesterManager

	// src/MessageTransmitter.algo.ts:434
	// assert(this.getNumEnabledAttesters() > 1)
	callsub getNumEnabledAttesters
	int 1
	>
	assert

	// src/MessageTransmitter.algo.ts:435
	// assert(this.getNumEnabledAttesters() > this.signatureThreshold.value)
	callsub getNumEnabledAttesters
	byte 0x7369676e61747572655468726573686f6c64 // "signatureThreshold"
	app_global_get
	>
	assert

	// src/MessageTransmitter.algo.ts:438
	// assert(this._isEnabledAttester(attester))
	frame_dig -1 // attester: bytes32
	callsub _isEnabledAttester
	assert

	// src/MessageTransmitter.algo.ts:441
	// index = this.offsetOfEnabledAttester(attester)
	frame_dig -1 // attester: bytes32
	callsub offsetOfEnabledAttester
	frame_bury 0 // index: uint64

	// src/MessageTransmitter.algo.ts:445
	// box_splice("enabledAttesters", (32 * index) + 2, 32, '')
	byte 0x656e61626c6564417474657374657273 // "enabledAttesters"
	int 32
	frame_dig 0 // index: uint64
	*
	int 2
	+
	int 32
	byte 0x // ""
	box_splice

	// src/MessageTransmitter.algo.ts:450
	// box_resize("enabledAttesters", this.enabledAttesters.size - 32)
	byte 0x656e61626c6564417474657374657273 // "enabledAttesters"
	dup
	box_len
	assert
	int 32
	-
	box_resize
	retsub

abi_route_setSignatureThreshold:
	// newSignatureThreshold: uint64
	txna ApplicationArgs 1
	btoi

	// execute setSignatureThreshold(uint64)void
	callsub setSignatureThreshold
	int 1
	return

// setSignatureThreshold(uint64)void
//
// @notice Sets the threshold of signatures required to attest to a message.
// (This is the m in m/n multisig.)
// @dev new signature threshold must be nonzero, and must not exceed number
// of enabled attesters.
// @param newSignatureThreshold new signature threshold
setSignatureThreshold:
	proto 1 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// src/MessageTransmitter.algo.ts:463
	// this.onlyAttesterManager()
	callsub onlyAttesterManager

	// src/MessageTransmitter.algo.ts:465
	// assert(newSignatureThreshold)
	frame_dig -1 // newSignatureThreshold: uint<64>
	assert

	// src/MessageTransmitter.algo.ts:466
	// assert(newSignatureThreshold <= this.getNumEnabledAttesters())
	frame_dig -1 // newSignatureThreshold: uint<64>
	callsub getNumEnabledAttesters
	<=
	assert

	// src/MessageTransmitter.algo.ts:467
	// assert(newSignatureThreshold != this.signatureThreshold.value)
	frame_dig -1 // newSignatureThreshold: uint<64>
	byte 0x7369676e61747572655468726573686f6c64 // "signatureThreshold"
	app_global_get
	!=
	assert

	// src/MessageTransmitter.algo.ts:469
	// _oldSignatureThreshold: uint<64> = this.signatureThreshold.value
	byte 0x7369676e61747572655468726573686f6c64 // "signatureThreshold"
	app_global_get
	frame_bury 0 // _oldSignatureThreshold: uint<64>

	// src/MessageTransmitter.algo.ts:470
	// this.signatureThreshold.value = newSignatureThreshold
	byte 0x7369676e61747572655468726573686f6c64 // "signatureThreshold"
	frame_dig -1 // newSignatureThreshold: uint<64>
	app_global_put

	// src/MessageTransmitter.algo.ts:472
	// this.SignatureThresholdUpdated.log({ oldSignatureThreshold: _oldSignatureThreshold, newSignatureThreshold: this.signatureThreshold.value })
	byte 0x2a3c3178 // SignatureThresholdUpdated(uint64,uint64)
	frame_dig 0 // _oldSignatureThreshold: uint<64>
	itob
	byte 0x7369676e61747572655468726573686f6c64 // "signatureThreshold"
	app_global_get
	itob
	concat
	concat
	log
	retsub

abi_route_sendMessage:
	// The ABI return prefix
	byte 0x151f7c75

	// messageBody: byte[]
	txna ApplicationArgs 3
	extract 2 0

	// recipient: byte[32]
	txna ApplicationArgs 2
	dup
	len
	int 32
	==
	assert

	// destinationDomain: uint32
	txna ApplicationArgs 1
	dup
	len
	int 4
	==
	assert
	btoi

	// execute sendMessage(byte[],byte[32],uint32)uint64
	callsub sendMessage
	itob
	concat
	log
	int 1
	return

// sendMessage(byte[],byte[32],uint32)uint64
//
// @notice Send the message to the destination domain and recipient
// @dev Increment nonce, format the message, and emit `MessageSent` event with message information.
// @param destinationDomain Domain of destination chain
// @param recipient Address of message recipient on destination chain as bytes32
// @param messageBody Raw bytes content of message
// @return nonce reserved by message
sendMessage:
	proto 3 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dup

	// src/MessageTransmitter.algo.ts:490
	// _nonce = this._reserveAndIncrementNonce()
	callsub _reserveAndIncrementNonce
	frame_bury 0 // _nonce: uint64

	// src/MessageTransmitter.algo.ts:491
	// _messageSender = bzero(24) + itob(globals.callerApplicationID)
	byte 0x000000000000000000000000000000000000000000000000
	global CallerApplicationID
	itob
	concat
	frame_bury 1 // _messageSender: byte[]

	// src/MessageTransmitter.algo.ts:493
	// this._sendMessage(
	// 			destinationDomain,
	// 			recipient,
	// 			bzero(32) as bytes32,
	// 			_messageSender,
	// 			_nonce,
	// 			messageBody
	// 		)
	frame_dig -3 // messageBody: bytes
	frame_dig 0 // _nonce: uint64
	frame_dig 1 // _messageSender: byte[]
	byte 0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
	byte 0x
	dup
	b==
	assert
	extract 0 32
	frame_dig -2 // recipient: bytes32
	frame_dig -1 // destinationDomain: uint<32>
	callsub _sendMessage

	// src/MessageTransmitter.algo.ts:502
	// return _nonce;
	frame_dig 0 // _nonce: uint64

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 1
	retsub

abi_route_replaceMessage:
	// newDestinationCaller: byte[32]
	txna ApplicationArgs 4
	dup
	len
	int 32
	==
	assert

	// newMessageBody: byte[]
	txna ApplicationArgs 3
	extract 2 0

	// originalAttestation: byte[]
	txna ApplicationArgs 2
	extract 2 0

	// originalMessage: byte[]
	txna ApplicationArgs 1
	extract 2 0

	// execute replaceMessage(byte[32],byte[],byte[],byte[])void
	callsub replaceMessage
	int 1
	return

// replaceMessage(byte[32],byte[],byte[],byte[])void
//
// @notice Replace a message with a new message body and/or destination caller.
// @dev The `originalAttestation` must be a valid attestation of `originalMessage`.
// Reverts if msg.sender does not match sender of original message, or if the source domain of the original message
// does not match this MessageTransmitter's local domain.
// @param originalMessage original message to replace
// @param originalAttestation attestation of `originalMessage`
// @param newMessageBody new message body of replaced message
// @param newDestinationCaller the new destination caller, which may be the
// same as the original destination caller, a new destination caller, or an empty
// destination caller (bytes32(0), indicating that any destination caller is valid.)
replaceMessage:
	proto 4 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 6

	// src/MessageTransmitter.algo.ts:525
	// this._verifyAttestationSignatures(originalMessage, originalAttestation)
	frame_dig -2 // originalAttestation: bytes
	frame_dig -1 // originalMessage: bytes
	callsub _verifyAttestationSignatures

	// src/MessageTransmitter.algo.ts:527
	// message_start = extract_uint16(originalMessage, 0)
	frame_dig -1 // originalMessage: bytes
	int 0
	extract_uint16
	frame_bury 0 // message_start: uint64

	// src/MessageTransmitter.algo.ts:528
	// message_size = 116
	int 116
	frame_bury 1 // message_size: uint64

	// src/MessageTransmitter.algo.ts:529
	// _message = castBytes<Message>(substring3(originalMessage, message_start, message_start + message_size))
	frame_dig -1 // originalMessage: bytes
	frame_dig 0 // message_start: uint64
	frame_dig 0 // message_start: uint64
	int 116 // message_size: uint64
	+
	substring3
	frame_bury 2 // _message: (uint32,uint32,uint32,uint64,byte[32],byte[32],byte[32])

	// src/MessageTransmitter.algo.ts:532
	// this._validateMessageFormat(_message)
	frame_dig 2 // _message: (uint32,uint32,uint32,uint64,byte[32],byte[32],byte[32])
	callsub _validateMessageFormat

	// src/MessageTransmitter.algo.ts:537
	// assert(<bytes32>(bzero(24) + itob(globals.callerApplicationID)) === _sender)
	byte 0x000000000000000000000000000000000000000000000000
	global CallerApplicationID
	itob
	concat
	byte 0x0000000000000000000000000000000000000000000000000000000000000000
	concat
	dup
	extract 32 0
	byte 0x
	b==
	assert
	extract 0 32
	frame_dig 2 // _message: (uint32,uint32,uint32,uint64,byte[32],byte[32],byte[32])
	extract 20 32
	==
	assert

	// src/MessageTransmitter.algo.ts:540
	// _sourceDomain = _message._msgSourceDomain
	frame_dig 2 // _message: (uint32,uint32,uint32,uint64,byte[32],byte[32],byte[32])
	extract 4 4
	btoi
	frame_bury 3 // _sourceDomain: uint32

	// src/MessageTransmitter.algo.ts:541
	// assert(_sourceDomain === this.localDomain.value)
	frame_dig 3 // _sourceDomain: uint32
	byte 0x6c6f63616c446f6d61696e // "localDomain"
	app_global_get
	btoi
	==
	assert

	// src/MessageTransmitter.algo.ts:543
	// _destinationDomain = _message._msgDestinationDomain
	frame_dig 2 // _message: (uint32,uint32,uint32,uint64,byte[32],byte[32],byte[32])
	extract 8 4
	btoi
	frame_bury 4 // _destinationDomain: uint32

	// src/MessageTransmitter.algo.ts:545
	// _nonce = _message._msgNonce
	frame_dig 2 // _message: (uint32,uint32,uint32,uint64,byte[32],byte[32],byte[32])
	extract 12 8
	btoi
	frame_bury 5 // _nonce: uint64

	// src/MessageTransmitter.algo.ts:547
	// this._sendMessage(
	// 			_destinationDomain,
	// 			_recipient,
	// 			newDestinationCaller,
	// 			_sender,
	// 			_nonce,
	// 			newMessageBody
	// 		)
	frame_dig -3 // newMessageBody: bytes
	frame_dig 5 // _nonce: uint64
	frame_dig 2 // _message: (uint32,uint32,uint32,uint64,byte[32],byte[32],byte[32])
	extract 20 32
	frame_dig -4 // newDestinationCaller: bytes32
	frame_dig 2 // _message: (uint32,uint32,uint32,uint64,byte[32],byte[32],byte[32])
	extract 52 32
	frame_dig 4 // _destinationDomain: uint32
	callsub _sendMessage
	retsub

abi_route_sendMessageWithCaller:
	// The ABI return prefix
	byte 0x151f7c75

	// messageBody: byte[]
	txna ApplicationArgs 4
	extract 2 0

	// destinationCaller: byte[32]
	txna ApplicationArgs 3
	dup
	len
	int 32
	==
	assert

	// recipient: byte[32]
	txna ApplicationArgs 2
	dup
	len
	int 32
	==
	assert

	// destinationDomain: uint32
	txna ApplicationArgs 1
	dup
	len
	int 4
	==
	assert
	btoi

	// execute sendMessageWithCaller(byte[],byte[32],byte[32],uint32)uint64
	callsub sendMessageWithCaller
	itob
	concat
	log
	int 1
	return

// sendMessageWithCaller(byte[],byte[32],byte[32],uint32)uint64
//
// @notice Send the message to the destination domain and recipient, for a specified `destinationCaller` on the
// destination domain.
// @dev Increment nonce, format the message, and emit `MessageSent` event with message information.
// WARNING: if the `destinationCaller` does not represent a valid address, then it will not be possible
// to broadcast the message on the destination domain. This is an advanced feature, and the standard
// sendMessage() should be preferred for use cases where a specific destination caller is not required.
// @param destinationDomain Domain of destination chain
// @param recipient Address of message recipient on destination domain as bytes32
// @param destinationCaller caller on the destination domain, as bytes32
// @param messageBody Raw bytes content of message
// @return nonce reserved by message
sendMessageWithCaller:
	proto 4 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dup

	// src/MessageTransmitter.algo.ts:577
	// assert(destinationCaller != bzero(32) as bytes32)
	frame_dig -3 // destinationCaller: bytes32
	byte 0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
	byte 0x
	dup
	b==
	assert
	extract 0 32
	!=
	assert

	// src/MessageTransmitter.algo.ts:579
	// _nonce = this._reserveAndIncrementNonce()
	callsub _reserveAndIncrementNonce
	frame_bury 0 // _nonce: uint64

	// src/MessageTransmitter.algo.ts:580
	// _messageSender = bzero(24) + itob(globals.callerApplicationID)
	byte 0x000000000000000000000000000000000000000000000000
	global CallerApplicationID
	itob
	concat
	frame_bury 1 // _messageSender: byte[]

	// src/MessageTransmitter.algo.ts:582
	// this._sendMessage(
	// 			destinationDomain,
	// 			recipient,
	// 			destinationCaller,
	// 			_messageSender,
	// 			_nonce,
	// 			messageBody
	// 		)
	frame_dig -4 // messageBody: bytes
	frame_dig 0 // _nonce: uint64
	frame_dig 1 // _messageSender: byte[]
	frame_dig -3 // destinationCaller: bytes32
	frame_dig -2 // recipient: bytes32
	frame_dig -1 // destinationDomain: uint<32>
	callsub _sendMessage

	// src/MessageTransmitter.algo.ts:591
	// return _nonce;
	frame_dig 0 // _nonce: uint64

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 1
	retsub

abi_route_receiveMessage:
	// The ABI return prefix
	byte 0x151f7c75

	// attestation: byte[]
	txna ApplicationArgs 2
	extract 2 0

	// message: byte[]
	txna ApplicationArgs 1
	extract 2 0

	// fee: pay
	txn GroupIndex
	int 1
	-
	dup
	gtxns TypeEnum
	int pay
	==
	assert

	// execute receiveMessage(byte[],byte[],pay)bool
	callsub receiveMessage
	byte 0x00
	int 0
	uncover 2
	setbit
	concat
	log
	int 1
	return

// receiveMessage(byte[],byte[],pay)bool
//
// @notice Receive a message. Messages with a given nonce
// can only be broadcast once for a (sourceDomain, destinationDomain)
// pair. The message body of a valid message is passed to the
// specified recipient for further processing.
//
// @dev Attestation format:
// A valid attestation is the concatenated 65-byte signature(s) of exactly
// `thresholdSignature` signatures, in increasing order of attester address.
// ***If the attester addresses recovered from signatures are not in
// increasing order, signature verification will fail.***
// If incorrect number of signatures or duplicate signatures are supplied,
// signature verification will fail.
//
// Message format:
// Field                 Bytes      Type       Index
// version               4          uint32     0
// sourceDomain          4          uint32     4
// destinationDomain     4          uint32     8
// nonce                 8          uint64     12
// sender                32         bytes32    20
// recipient             32         bytes32    52
// destinationCaller     32         bytes32    84
// messageBody           dynamic    bytes      116
//
// @param message Message bytes
// @param attestation Concatenated 65-byte signature(s) of `message`, in increasing order
// of the attester address recovered from signatures.
// @return success bool, true if successful
receiveMessage:
	proto 3 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 8

	// src/MessageTransmitter.algo.ts:631
	// this._verifyAttestationSignatures(message, attestation)
	frame_dig -3 // attestation: bytes
	frame_dig -2 // message: bytes
	callsub _verifyAttestationSignatures

	// src/MessageTransmitter.algo.ts:633
	// verifyPayTxn(fee, {
	// 			receiver: this.app.address,
	// 			amount: (2500) + (400 * (12)),
	// 		})
	// verify receiver
	frame_dig -1 // fee: PayTxn
	gtxns Receiver
	global CurrentApplicationAddress
	==
	assert

	// verify amount
	frame_dig -1 // fee: PayTxn
	gtxns Amount
	int 7300
	==
	assert

	// src/MessageTransmitter.algo.ts:638
	// message_start = extract_uint16(message, 0)
	frame_dig -2 // message: bytes
	int 0
	extract_uint16
	frame_bury 0 // message_start: uint64

	// src/MessageTransmitter.algo.ts:639
	// message_size = 116
	int 116
	frame_bury 1 // message_size: uint64

	// src/MessageTransmitter.algo.ts:640
	// _message = castBytes<Message>(substring3(message, message_start, message_start + message_size))
	frame_dig -2 // message: bytes
	frame_dig 0 // message_start: uint64
	frame_dig 0 // message_start: uint64
	int 116 // message_size: uint64
	+
	substring3
	frame_bury 2 // _message: (uint32,uint32,uint32,uint64,byte[32],byte[32],byte[32])

	// src/MessageTransmitter.algo.ts:642
	// msg_body_start = message_start + message_size
	frame_dig 0 // message_start: uint64
	int 116 // message_size: uint64
	+
	frame_bury 3 // msg_body_start: uint64

	// src/MessageTransmitter.algo.ts:643
	// msg_body_size = message.length - msg_body_start
	frame_dig -2 // message: bytes
	len
	frame_dig 3 // msg_body_start: uint64
	-
	frame_bury 4 // msg_body_size: uint64

	// src/MessageTransmitter.algo.ts:644
	// _messageBody = substring3(message, msg_body_start, msg_body_start + msg_body_size)
	frame_dig -2 // message: bytes
	frame_dig 3 // msg_body_start: uint64
	frame_dig 3 // msg_body_start: uint64
	frame_dig 4 // msg_body_size: uint64
	+
	substring3
	frame_bury 5 // _messageBody: byte[]

	// src/MessageTransmitter.algo.ts:655
	// this._validateMessageFormat(_message)
	frame_dig 2 // _message: (uint32,uint32,uint32,uint64,byte[32],byte[32],byte[32])
	callsub _validateMessageFormat

	// src/MessageTransmitter.algo.ts:658
	// assert(_message._msgDestinationDomain === this.localDomain.value)
	frame_dig 2 // _message: (uint32,uint32,uint32,uint64,byte[32],byte[32],byte[32])
	extract 8 4
	btoi
	byte 0x6c6f63616c446f6d61696e // "localDomain"
	app_global_get
	btoi
	==
	assert

	// if4_condition
	// src/MessageTransmitter.algo.ts:661
	// _message._msgDestinationCaller != bzero(32) as bytes32
	frame_dig 2 // _message: (uint32,uint32,uint32,uint64,byte[32],byte[32],byte[32])
	extract 84 32
	byte 0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
	byte 0x
	dup
	b==
	assert
	extract 0 32
	!=
	bz if4_end

	// if4_consequent
	// src/MessageTransmitter.algo.ts:662
	// assert(_message._msgDestinationCaller === rawBytes(this.txn.sender) as bytes32)
	frame_dig 2 // _message: (uint32,uint32,uint32,uint64,byte[32],byte[32],byte[32])
	extract 84 32
	txn Sender
	byte 0x0000000000000000000000000000000000000000000000000000000000000000
	concat
	dup
	extract 32 0
	byte 0x
	b==
	assert
	extract 0 32
	==
	assert

if4_end:
	// src/MessageTransmitter.algo.ts:666
	// assert(_message._msgVersion === this.version.value)
	frame_dig 2 // _message: (uint32,uint32,uint32,uint64,byte[32],byte[32],byte[32])
	extract 0 4
	btoi
	byte 0x76657273696f6e // "version"
	app_global_get
	btoi
	==
	assert

	// src/MessageTransmitter.algo.ts:671
	// box: SourceDomainNonceBox = {
	// 			sourceDomain: _message._msgSourceDomain,
	// 			nonce: _message._msgNonce
	// 		}
	frame_dig 2 // _message: (uint32,uint32,uint32,uint64,byte[32],byte[32],byte[32])
	extract 4 4
	btoi
	itob
	extract 4 4
	frame_dig 2 // _message: (uint32,uint32,uint32,uint64,byte[32],byte[32],byte[32])
	extract 12 8
	btoi
	itob
	concat
	frame_bury 6 // box: SourceDomainNonceBox

	// src/MessageTransmitter.algo.ts:677
	// assert(!this.usedNonces(box).exists)
	frame_dig 6 // box: SourceDomainNonceBox
	box_len
	swap
	pop
	!
	assert

	// src/MessageTransmitter.algo.ts:680
	// this.usedNonces(box).create(0)
	frame_dig 6 // box: SourceDomainNonceBox
	int 0
	box_create

	// src/MessageTransmitter.algo.ts:683
	// handled = sendMethodCall<[uint<32>, bytes32, bytes], boolean>({
	// 			applicationID: Application.fromID(extract_uint64(_message._msgRecipient, 24)),
	// 			name: 'handleReceiveMessage',
	// 			methodArgs: [
	// 				_message._msgSourceDomain,
	// 				_message._msgSender,
	// 				_messageBody
	// 			]
	// 		})
	itxn_begin
	int appl
	itxn_field TypeEnum
	method "handleReceiveMessage(uint32,byte[32],byte[])bool"
	itxn_field ApplicationArgs

	// src/MessageTransmitter.algo.ts:684
	// applicationID: Application.fromID(extract_uint64(_message._msgRecipient, 24))
	frame_dig 2 // _message: (uint32,uint32,uint32,uint64,byte[32],byte[32],byte[32])
	extract 52 32
	int 24
	extract_uint64
	itxn_field ApplicationID

	// src/MessageTransmitter.algo.ts:686
	// methodArgs: [
	// 				_message._msgSourceDomain,
	// 				_message._msgSender,
	// 				_messageBody
	// 			]
	frame_dig 2 // _message: (uint32,uint32,uint32,uint64,byte[32],byte[32],byte[32])
	extract 4 4
	btoi
	itob
	extract 4 4
	itxn_field ApplicationArgs
	frame_dig 2 // _message: (uint32,uint32,uint32,uint64,byte[32],byte[32],byte[32])
	extract 20 32
	itxn_field ApplicationArgs
	frame_dig 5 // _messageBody: byte[]
	dup
	len
	itob
	extract 6 2
	swap
	concat
	itxn_field ApplicationArgs

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	itxn NumLogs
	int 1
	-
	itxnas Logs
	extract 4 0
	int 0
	getbit
	frame_bury 7 // handled: bool

	// src/MessageTransmitter.algo.ts:695
	// this.MessageReceived.log(
	// 			{
	// 				caller: this.txn.sender,
	// 				sourceDomain: _message._msgSourceDomain,
	// 				nonce: _message._msgNonce,
	// 				sender: _message._msgSender,
	// 				messageBody: _messageBody
	// 			}
	// 		)
	byte 0xe1ad20ff // MessageReceived(address,uint32,uint64,byte[32],byte[])
	byte 0x // initial head
	byte 0x // initial tail
	byte 0x004e // initial head offset
	txn Sender
	callsub process_static_tuple_element
	frame_dig 2 // _message: (uint32,uint32,uint32,uint64,byte[32],byte[32],byte[32])
	extract 4 4
	btoi
	itob
	extract 4 4
	callsub process_static_tuple_element
	frame_dig 2 // _message: (uint32,uint32,uint32,uint64,byte[32],byte[32],byte[32])
	extract 12 8
	btoi
	itob
	callsub process_static_tuple_element
	frame_dig 2 // _message: (uint32,uint32,uint32,uint64,byte[32],byte[32],byte[32])
	extract 20 32
	callsub process_static_tuple_element
	frame_dig 5 // _messageBody: byte[]
	dup
	len
	itob
	extract 6 2
	swap
	concat
	callsub process_dynamic_tuple_element
	pop // pop head offset
	concat // concat head and tail
	concat
	log

	// src/MessageTransmitter.algo.ts:705
	// return true;
	int 1

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 7
	retsub

abi_route_setMaxMessageBodySize:
	// newMaxMessageBodySize: uint64
	txna ApplicationArgs 1
	btoi

	// execute setMaxMessageBodySize(uint64)void
	callsub setMaxMessageBodySize
	int 1
	return

// setMaxMessageBodySize(uint64)void
//
// @notice Sets the max message body size
// @dev This value should not be reduced without good reason,
// to avoid impacting users who rely on large messages.
// @param newMaxMessageBodySize new max message body size, in bytes
setMaxMessageBodySize:
	proto 1 0

	// src/MessageTransmitter.algo.ts:717
	// this.onlyOwner()
	callsub onlyOwner

	// src/MessageTransmitter.algo.ts:719
	// this.maxMessageBodySize.value = newMaxMessageBodySize
	byte 0x6d61784d657373616765426f647953697a65 // "maxMessageBodySize"
	frame_dig -1 // newMaxMessageBodySize: uint<64>
	app_global_put

	// src/MessageTransmitter.algo.ts:721
	// this.MaxMessageBodySizeUpdated.log({ newMaxMessageBodySize: this.maxMessageBodySize.value })
	byte 0x39d67349 // MaxMessageBodySizeUpdated(uint64)
	byte 0x6d61784d657373616765426f647953697a65 // "maxMessageBodySize"
	app_global_get
	itob
	concat
	log
	retsub

abi_route_deploy:
	// _version: uint32
	txna ApplicationArgs 3
	dup
	len
	int 4
	==
	assert
	btoi

	// _maxMessageBodySize: uint64
	txna ApplicationArgs 2
	btoi

	// _localDomain: uint32
	txna ApplicationArgs 1
	dup
	len
	int 4
	==
	assert
	btoi

	// execute deploy(uint32,uint64,uint32)void
	callsub deploy
	int 1
	return

// deploy(uint32,uint64,uint32)void
deploy:
	proto 3 0

	// src/MessageTransmitter.algo.ts:733
	// this.localDomain.value = _localDomain
	byte 0x6c6f63616c446f6d61696e // "localDomain"
	frame_dig -1 // _localDomain: uint<32>
	itob
	extract 4 4
	app_global_put

	// src/MessageTransmitter.algo.ts:734
	// this.maxMessageBodySize.value = _maxMessageBodySize
	byte 0x6d61784d657373616765426f647953697a65 // "maxMessageBodySize"
	frame_dig -2 // _maxMessageBodySize: uint<64>
	app_global_put

	// src/MessageTransmitter.algo.ts:735
	// this.version.value = _version
	byte 0x76657273696f6e // "version"
	frame_dig -3 // _version: uint<32>
	itob
	extract 4 4
	app_global_put

	// src/MessageTransmitter.algo.ts:738
	// this._transferOwnership(this.txn.sender)
	txn Sender
	callsub _transferOwnership

	// src/MessageTransmitter.algo.ts:741
	// this._setAttesterManager(this.txn.sender)
	txn Sender
	callsub _setAttesterManager

	// src/MessageTransmitter.algo.ts:742
	// this.signatureThreshold.value = 1
	byte 0x7369676e61747572655468726573686f6c64 // "signatureThreshold"
	int 1
	app_global_put
	retsub

create_NoOp:
	method "deploy(uint32,uint64,uint32)void"
	txna ApplicationArgs 0
	match abi_route_deploy
	err

call_NoOp:
	method "transferOwnership(address)void"
	method "enableAttester(byte[32])void"
	method "offsetOfEnabledAttester(byte[32])uint64"
	method "getNumEnabledAttesters()uint64"
	method "updateAttesterManager(address)void"
	method "disableAttester(byte[32])void"
	method "setSignatureThreshold(uint64)void"
	method "sendMessage(uint32,byte[32],byte[])uint64"
	method "replaceMessage(byte[],byte[],byte[],byte[32])void"
	method "sendMessageWithCaller(uint32,byte[32],byte[32],byte[])uint64"
	method "receiveMessage(pay,byte[],byte[])bool"
	method "setMaxMessageBodySize(uint64)void"
	txna ApplicationArgs 0
	match abi_route_transferOwnership abi_route_enableAttester abi_route_offsetOfEnabledAttester abi_route_getNumEnabledAttesters abi_route_updateAttesterManager abi_route_disableAttester abi_route_setSignatureThreshold abi_route_sendMessage abi_route_replaceMessage abi_route_sendMessageWithCaller abi_route_receiveMessage abi_route_setMaxMessageBodySize
	err

process_static_tuple_element:
	proto 4 3
	frame_dig -4 // tuple head
	frame_dig -1 // element
	concat
	frame_dig -3 // tuple tail
	frame_dig -2 // head offset
	retsub

process_dynamic_tuple_element:
	proto 4 3
	frame_dig -4 // tuple head
	frame_dig -2 // head offset
	concat
	frame_bury -4 // tuple head
	frame_dig -1 // element
	dup
	len
	frame_dig -2 // head offset
	btoi
	+
	itob
	extract 6 2
	frame_bury -2 // head offset
	frame_dig -3 // tuple tail
	swap
	concat
	frame_bury -3 // tuple tail
	frame_dig -4 // tuple head
	frame_dig -3 // tuple tail
	frame_dig -2 // head offset
	retsub