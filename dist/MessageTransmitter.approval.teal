#pragma version 10

// This TEAL was generated by TEALScript v0.79.0
// https://github.com/algorandfoundation/TEALScript

// This contract is compliant with and/or implements the following ARCs: [ ARC4 ]

// The following ten lines of TEAL handle initial program flow
// This pattern is used to make it easy for anyone to parse the start of the program and determine if a specific action is allowed
// Here, action refers to the OnComplete in combination with whether the app is being created or called
// Every possible action for this contract is represented in the switch statement
// If the action is not implmented in the contract, its respective branch will be "NOT_IMPLEMENTED" which just contains "err"
txn ApplicationID
!
int 6
*
txn OnCompletion
+
switch call_NoOp NOT_IMPLEMENTED NOT_IMPLEMENTED NOT_IMPLEMENTED NOT_IMPLEMENTED NOT_IMPLEMENTED create_NoOp NOT_IMPLEMENTED NOT_IMPLEMENTED NOT_IMPLEMENTED NOT_IMPLEMENTED NOT_IMPLEMENTED

NOT_IMPLEMENTED:
	err

// onlyOwner(): void
//
// @dev Throws if called by any account other than the owner.
onlyOwner:
	proto 0 0

	// src/roles/Ownable.algo.ts:52
	// assert(this.txn.sender === this._owner.value)
	txn Sender
	byte 0x5f6f776e6572 // "_owner"
	app_global_get
	==
	assert
	retsub

// owner()address
abi_route_owner:
	// The ABI return prefix
	byte 0x151f7c75

	// execute owner()address
	callsub owner
	concat
	log
	int 1
	return

// owner(): Address
//
// @dev Returns the address of the current owner.
owner:
	proto 0 1

	// src/roles/Ownable.algo.ts:62
	// return this._owner.value;
	byte 0x5f6f776e6572 // "_owner"
	app_global_get
	retsub

// _checkOwner()void
abi_route__checkOwner:
	// execute _checkOwner()void
	callsub _checkOwner
	int 1
	return

// _checkOwner(): void
//
// @dev Throws if the sender is not the owner.
_checkOwner:
	proto 0 0

	// src/roles/Ownable.algo.ts:70
	// assert(this.owner() == this.txn.sender)
	callsub owner
	txn Sender
	==
	assert
	retsub

// transferOwnership(address)void
abi_route_transferOwnership:
	// newOwner: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// execute transferOwnership(address)void
	callsub transferOwnership
	int 1
	return

// transferOwnership(newOwner: Address): void
//
// @dev Transfers ownership of the application to a new account (`newOwner`).
// Can only be called by the current owner.
transferOwnership:
	proto 1 0

	// src/roles/Ownable.algo.ts:80
	// this.onlyOwner()
	callsub onlyOwner

	// src/roles/Ownable.algo.ts:82
	// assert(newOwner != globals.zeroAddress)
	frame_dig -1 // newOwner: Address
	global ZeroAddress
	!=
	assert

	// src/roles/Ownable.algo.ts:84
	// this._transferOwnership(newOwner)
	frame_dig -1 // newOwner: Address
	callsub _transferOwnership
	retsub

// _transferOwnership(newOwner: Address): void
//
// @dev Transfers ownership of the application to a new account (`newOwner`).
// Internal function without access restriction.
_transferOwnership:
	proto 1 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// src/roles/Ownable.algo.ts:94
	// oldOwner: Address = this._owner.exists ? this._owner.value : globals.zeroAddress
	txna Applications 0
	byte 0x5f6f776e6572 // "_owner"
	app_global_get_ex
	swap
	pop
	bz ternary1_false
	byte 0x5f6f776e6572 // "_owner"
	app_global_get
	b ternary1_end

ternary1_false:
	global ZeroAddress

ternary1_end:
	frame_bury 0 // oldOwner: Address

	// src/roles/Ownable.algo.ts:95
	// this._owner.value = newOwner
	byte 0x5f6f776e6572 // "_owner"
	frame_dig -1 // newOwner: Address
	app_global_put

	// src/roles/Ownable.algo.ts:97
	// this.OwnershipTransferred.log({ oldAddress: oldOwner, newAddress: newOwner })
	byte 0x9a223efb // OwnershipTransferred(address,address)
	frame_dig 0 // oldOwner: Address
	frame_dig -1 // newOwner: Address
	concat
	concat
	log
	retsub

// pendingOwner()address
abi_route_pendingOwner:
	// The ABI return prefix
	byte 0x151f7c75

	// execute pendingOwner()address
	callsub pendingOwner
	concat
	log
	int 1
	return

// pendingOwner(): Address
//
// @dev Returns the address of the pending owner.
pendingOwner:
	proto 0 1

	// src/roles/Ownable2Step.algo.ts:51
	// return this._pendingOwner.value;
	byte 0x5f70656e64696e674f776e6572 // "_pendingOwner"
	app_global_get
	retsub

// transferOwnership2S(address)void
abi_route_transferOwnership2S:
	// newOwner: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// execute transferOwnership2S(address)void
	callsub transferOwnership2S
	int 1
	return

// transferOwnership2S(newOwner: Address): void
//
// @dev Starts the ownership transfer of the contract to a new account. Replaces the pending transfer if there is one.
// Can only be called by the current owner.
// FIX: Once overrides exist, rename to transferOwnership
transferOwnership2S:
	proto 1 0

	// src/roles/Ownable2Step.algo.ts:62
	// this.onlyOwner()
	callsub onlyOwner

	// src/roles/Ownable2Step.algo.ts:64
	// this._pendingOwner.value = newOwner
	byte 0x5f70656e64696e674f776e6572 // "_pendingOwner"
	frame_dig -1 // newOwner: Address
	app_global_put

	// src/roles/Ownable2Step.algo.ts:66
	// this.OwnershipTransferStarted.log({
	//             previousAddress: this._owner.value,
	//             newAddress: newOwner
	//         })
	byte 0x2424ff2a // OwnershipTransferStarted(address,address)
	byte 0x5f6f776e6572 // "_owner"
	app_global_get
	frame_dig -1 // newOwner: Address
	concat
	concat
	log
	retsub

// acceptOwnership()void
abi_route_acceptOwnership:
	// execute acceptOwnership()void
	callsub acceptOwnership
	int 1
	return

// acceptOwnership(): void
//
// @dev The new owner accepts the ownership transfer.
acceptOwnership:
	proto 0 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// src/roles/Ownable2Step.algo.ts:76
	// sender: Address = this.txn.sender
	txn Sender
	frame_bury 0 // sender: Address

	// src/roles/Ownable2Step.algo.ts:77
	// assert(this.pendingOwner() == sender)
	callsub pendingOwner
	frame_dig 0 // sender: Address
	==
	assert

	// src/roles/Ownable2Step.algo.ts:79
	// this._transferOwnership2S(sender)
	frame_dig 0 // sender: Address
	callsub _transferOwnership2S
	retsub

// _transferOwnership2S(newOwner: Address): void
//
// @dev Transfers ownership of the contract to a new account (`newOwner`) and deletes any pending owner.
// Internal function without access restriction.
// FIX: Once overrides exist, rename to _transferOwnership
_transferOwnership2S:
	proto 1 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// src/roles/Ownable2Step.algo.ts:90
	// oldOwner: Address = this._owner.exists ? this._owner.value : globals.zeroAddress
	txna Applications 0
	byte 0x5f6f776e6572 // "_owner"
	app_global_get_ex
	swap
	pop
	bz ternary3_false
	byte 0x5f6f776e6572 // "_owner"
	app_global_get
	b ternary3_end

ternary3_false:
	global ZeroAddress

ternary3_end:
	frame_bury 0 // oldOwner: Address

	// src/roles/Ownable2Step.algo.ts:91
	// this._owner.value = newOwner
	byte 0x5f6f776e6572 // "_owner"
	frame_dig -1 // newOwner: Address
	app_global_put

	// src/roles/Ownable2Step.algo.ts:93
	// this.OwnershipTransferred.log({ oldAddress: oldOwner, newAddress: newOwner })
	byte 0x9a223efb // OwnershipTransferred(address,address)
	frame_dig 0 // oldOwner: Address
	frame_dig -1 // newOwner: Address
	concat
	concat
	log
	retsub

// whenNotPaused(): void
//
// @dev Modifier to make a function callable only when the contract is not paused.
whenNotPaused:
	proto 0 0

	// src/roles/Pausable.algo.ts:48
	// assert(!this.paused.value)
	byte 0x706175736564 // "paused"
	app_global_get
	int 0
	getbit
	!
	assert
	retsub

// onlyPauser(): void
//
// @dev throws if called by any account other than the pauser
onlyPauser:
	proto 0 0

	// src/roles/Pausable.algo.ts:55
	// assert(this.txn.sender === this._pauser.value)
	txn Sender
	byte 0x5f706175736572 // "_pauser"
	app_global_get
	==
	assert
	retsub

// pauser()address
abi_route_pauser:
	// The ABI return prefix
	byte 0x151f7c75

	// execute pauser()address
	callsub pauser
	concat
	log
	int 1
	return

// pauser(): Address
//
// @notice Returns current pauser
// @return Pauser's address
pauser:
	proto 0 1

	// src/roles/Pausable.algo.ts:65
	// return this._pauser.value;
	byte 0x5f706175736572 // "_pauser"
	app_global_get
	retsub

// pause()void
abi_route_pause:
	// execute pause()void
	callsub pause
	int 1
	return

// pause(): void
//
// @dev called by the owner to pause, triggers stopped state
pause:
	proto 0 0

	// src/roles/Pausable.algo.ts:74
	// this.onlyPauser()
	callsub onlyPauser

	// src/roles/Pausable.algo.ts:76
	// this.paused.value = true
	byte 0x706175736564 // "paused"
	int 1
	byte 0x00
	int 0
	uncover 2
	setbit
	app_global_put

	// src/roles/Pausable.algo.ts:77
	// this.Pause.log({})
	byte 0xcf23a30f // Pause()
	concat
	log
	retsub

// unpause()void
abi_route_unpause:
	// execute unpause()void
	callsub unpause
	int 1
	return

// unpause(): void
//
// @dev called by the owner to unpause, returns to normal state
unpause:
	proto 0 0

	// src/roles/Pausable.algo.ts:84
	// this.onlyPauser()
	callsub onlyPauser

	// src/roles/Pausable.algo.ts:86
	// this.paused.value = false
	byte 0x706175736564 // "paused"
	int 0
	byte 0x00
	int 0
	uncover 2
	setbit
	app_global_put

	// src/roles/Pausable.algo.ts:87
	// this.Unpause.log({})
	byte 0xb163ee0b // Unpause()
	concat
	log
	retsub

// updatePauser(address)void
abi_route_updatePauser:
	// _newPauser: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// execute updatePauser(address)void
	callsub updatePauser
	int 1
	return

// updatePauser(_newPauser: Address): void
//
// @dev update the pauser role
updatePauser:
	proto 1 0

	// src/roles/Pausable.algo.ts:94
	// this.onlyPauser()
	callsub onlyPauser

	// src/roles/Pausable.algo.ts:96
	// assert(_newPauser != globals.zeroAddress)
	frame_dig -1 // _newPauser: Address
	global ZeroAddress
	!=
	assert

	// src/roles/Pausable.algo.ts:97
	// this._pauser.value = _newPauser
	byte 0x5f706175736572 // "_pauser"
	frame_dig -1 // _newPauser: Address
	app_global_put

	// src/roles/Pausable.algo.ts:98
	// this.PauserChanged.log({ newAddress: this._pauser.value })
	byte 0xcc40923c // PauserChanged(address)
	byte 0x5f706175736572 // "_pauser"
	app_global_get
	concat
	log
	retsub

// onlyAttesterManager(): void
//
// @dev Throws if called by any account other than the attester manager.
onlyAttesterManager:
	proto 0 0

	// src/roles/Attestable.algo.ts:77
	// assert(this.txn.sender === this.attesterManager.value)
	txn Sender
	byte 0x61747465737465724d616e61676572 // "attesterManager"
	app_global_get
	==
	assert
	retsub

// enableAttester(byte[32])void
abi_route_enableAttester:
	// newAttester: byte[32]
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// execute enableAttester(byte[32])void
	callsub enableAttester
	int 1
	return

// enableAttester(newAttester: bytes32): void
//
// @notice Enables an attester
// @dev Only callable by attesterManager. New attester must not be attesters.
// @param newAttester attester to enable
enableAttester:
	proto 1 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// src/roles/Attestable.algo.ts:91
	// this.onlyAttesterManager()
	callsub onlyAttesterManager

	// if0_condition
	// src/roles/Attestable.algo.ts:94
	// !this.enabledAttesters.exists
	byte 0x656e61626c6564417474657374657273 // "enabledAttesters"
	box_len
	swap
	pop
	!
	bz if0_end

	// if0_consequent
	// src/roles/Attestable.algo.ts:95
	// this.enabledAttesters.create(2)
	byte 0x656e61626c6564417474657374657273 // "enabledAttesters"
	int 2
	box_create
	pop

if0_end:
	// src/roles/Attestable.algo.ts:99
	// assert(!this._isEnabledAttester(newAttester))
	frame_dig -1 // newAttester: bytes32
	callsub _isEnabledAttester
	!
	assert

	// src/roles/Attestable.algo.ts:101
	// originalSize = this.enabledAttesters.size
	byte 0x656e61626c6564417474657374657273 // "enabledAttesters"
	box_len
	assert
	frame_bury 0 // originalSize: uint64

	// src/roles/Attestable.algo.ts:106
	// box_resize("enabledAttesters", originalSize + 32)
	byte 0x656e61626c6564417474657374657273 // "enabledAttesters"
	frame_dig 0 // originalSize: uint64
	int 32
	+
	box_resize

	// src/roles/Attestable.algo.ts:110
	// box_splice("enabledAttesters", originalSize, 32, newAttester)
	byte 0x656e61626c6564417474657374657273 // "enabledAttesters"
	frame_dig 0 // originalSize: uint64
	int 32
	frame_dig -1 // newAttester: bytes32
	box_splice
	retsub

// offsetOfEnabledAttester(byte[32])uint64
abi_route_offsetOfEnabledAttester:
	// The ABI return prefix
	byte 0x151f7c75

	// attester: byte[32]
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// execute offsetOfEnabledAttester(byte[32])uint64
	callsub offsetOfEnabledAttester
	itob
	concat
	log
	int 1
	return

// offsetOfEnabledAttester(attester: bytes32): uint64
//
// @notice returns the index of a given `attester`, else fails
// @param attester attester to retrieve index of
// @return index of given `attester`, else fails
offsetOfEnabledAttester:
	proto 1 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dup

	// src/roles/Attestable.algo.ts:121
	// boxSize = this.enabledAttesters.size
	byte 0x656e61626c6564417474657374657273 // "enabledAttesters"
	box_len
	assert
	frame_bury 0 // boxSize: uint64

	// src/roles/Attestable.algo.ts:122
	// i = 2
	int 2
	frame_bury 1 // i: uint64

for_0:
	// src/roles/Attestable.algo.ts:122
	// i < boxSize
	frame_dig 1 // i: uint64
	frame_dig 0 // boxSize: uint64
	<
	bz for_0_end

	// if1_condition
	// src/roles/Attestable.algo.ts:123
	// attester == this.enabledAttesters.value[i]
	frame_dig -1 // attester: bytes32
	byte 0x656e61626c6564417474657374657273 // "enabledAttesters"
	int 2
	int 0
	box_extract
	store 255 // full array
	int 0 // initial offset
	frame_dig 1 // i: uint64
	int 32
	* // acc * typeLength
	+
	load 255 // full array
	swap
	int 32
	extract3
	==
	bz if1_end

	// if1_consequent
	// src/roles/Attestable.algo.ts:124
	// return i;
	frame_dig 1 // i: uint64

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 1
	retsub

if1_end:
	// src/roles/Attestable.algo.ts:122
	// i = i + 32
	frame_dig 1 // i: uint64
	int 32
	+
	frame_bury 1 // i: uint64
	b for_0

for_0_end:
	// src/roles/Attestable.algo.ts:127
	// assert(0)
	int 0
	assert

	// src/roles/Attestable.algo.ts:128
	// return 0;
	int 0

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 1
	retsub

// getNumEnabledAttesters()uint64
abi_route_getNumEnabledAttesters:
	// The ABI return prefix
	byte 0x151f7c75

	// execute getNumEnabledAttesters()uint64
	callsub getNumEnabledAttesters
	itob
	concat
	log
	int 1
	return

// getNumEnabledAttesters(): uint64
//
// @notice returns the number of enabled attesters
// @return number of enabled attesters
getNumEnabledAttesters:
	proto 0 1

	// src/roles/Attestable.algo.ts:136
	// return this.enabledAttesters.size / 32;
	byte 0x656e61626c6564417474657374657273 // "enabledAttesters"
	box_len
	assert
	int 32
	/
	retsub

// updateAttesterManager(address)void
abi_route_updateAttesterManager:
	// newAttesterManager: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// execute updateAttesterManager(address)void
	callsub updateAttesterManager
	int 1
	return

// updateAttesterManager(newAttesterManager: Address): void
//
// FIX: onlyOwner or onlyAttesterManager?
// @dev Allows the current attester manager to transfer control of the application to a newAttesterManager.
// @param newAttesterManager The address to update attester manager to.
updateAttesterManager:
	proto 1 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// src/roles/Attestable.algo.ts:145
	// this.onlyOwner()
	callsub onlyOwner

	// src/roles/Attestable.algo.ts:147
	// assert(newAttesterManager != globals.zeroAddress)
	frame_dig -1 // newAttesterManager: Address
	global ZeroAddress
	!=
	assert

	// src/roles/Attestable.algo.ts:149
	// _oldAttesterManager: Address = this.attesterManager.exists ? this.attesterManager.value : globals.zeroAddress
	txna Applications 0
	byte 0x61747465737465724d616e61676572 // "attesterManager"
	app_global_get_ex
	swap
	pop
	bz ternary5_false
	byte 0x61747465737465724d616e61676572 // "attesterManager"
	app_global_get
	b ternary5_end

ternary5_false:
	global ZeroAddress

ternary5_end:
	frame_bury 0 // _oldAttesterManager: Address

	// src/roles/Attestable.algo.ts:150
	// this._setAttesterManager(newAttesterManager)
	frame_dig -1 // newAttesterManager: Address
	callsub _setAttesterManager

	// src/roles/Attestable.algo.ts:152
	// this.AttesterManagerUpdated.log({ previousAttesterManager: _oldAttesterManager, newAttesterManager: newAttesterManager })
	byte 0x8d199cdf // AttesterManagerUpdated(address,address)
	frame_dig 0 // _oldAttesterManager: Address
	frame_dig -1 // newAttesterManager: Address
	concat
	concat
	log
	retsub

// disableAttester(byte[32])void
abi_route_disableAttester:
	// attester: byte[32]
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// execute disableAttester(byte[32])void
	callsub disableAttester
	int 1
	return

// disableAttester(attester: bytes32): void
//
// @notice Disables an attester
// @dev Only callable by attesterManager. Disabling the attester is not allowed if there is only one attester
// enabled, or if it would cause the number of enabled attesters to become less than signatureThreshold.
// (Attester must be currently enabled.)
// @param attester attester to disable
disableAttester:
	proto 1 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// src/roles/Attestable.algo.ts:163
	// this.onlyAttesterManager()
	callsub onlyAttesterManager

	// src/roles/Attestable.algo.ts:165
	// assert(this.getNumEnabledAttesters() > 1)
	callsub getNumEnabledAttesters
	int 1
	>
	assert

	// src/roles/Attestable.algo.ts:166
	// assert(this.getNumEnabledAttesters() > this.signatureThreshold.value)
	callsub getNumEnabledAttesters
	byte 0x7369676e61747572655468726573686f6c64 // "signatureThreshold"
	app_global_get
	>
	assert

	// src/roles/Attestable.algo.ts:169
	// assert(this._isEnabledAttester(attester))
	frame_dig -1 // attester: bytes32
	callsub _isEnabledAttester
	assert

	// src/roles/Attestable.algo.ts:172
	// index = this.offsetOfEnabledAttester(attester)
	frame_dig -1 // attester: bytes32
	callsub offsetOfEnabledAttester
	frame_bury 0 // index: uint64

	// src/roles/Attestable.algo.ts:176
	// box_splice("enabledAttesters", (32 * index) + 2, 32, '')
	byte 0x656e61626c6564417474657374657273 // "enabledAttesters"
	int 32
	frame_dig 0 // index: uint64
	*
	int 2
	+
	int 32
	byte 0x // ""
	box_splice

	// src/roles/Attestable.algo.ts:181
	// box_resize("enabledAttesters", this.enabledAttesters.size - 32)
	byte 0x656e61626c6564417474657374657273 // "enabledAttesters"
	dup
	box_len
	assert
	int 32
	-
	box_resize
	retsub

// setSignatureThreshold(uint64)void
abi_route_setSignatureThreshold:
	// newSignatureThreshold: uint64
	txna ApplicationArgs 1
	btoi

	// execute setSignatureThreshold(uint64)void
	callsub setSignatureThreshold
	int 1
	return

// setSignatureThreshold(newSignatureThreshold: uint64): void
//
// @notice Sets the threshold of signatures required to attest to a message.
// (This is the m in m/n multisig.)
// @dev new signature threshold must be nonzero, and must not exceed number
// of enabled attesters.
// @param newSignatureThreshold new signature threshold
setSignatureThreshold:
	proto 1 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// src/roles/Attestable.algo.ts:194
	// this.onlyAttesterManager()
	callsub onlyAttesterManager

	// src/roles/Attestable.algo.ts:196
	// assert(newSignatureThreshold)
	frame_dig -1 // newSignatureThreshold: uint64
	assert

	// src/roles/Attestable.algo.ts:197
	// assert(newSignatureThreshold <= this.getNumEnabledAttesters())
	frame_dig -1 // newSignatureThreshold: uint64
	callsub getNumEnabledAttesters
	<=
	assert

	// src/roles/Attestable.algo.ts:198
	// assert(newSignatureThreshold != this.signatureThreshold.value)
	frame_dig -1 // newSignatureThreshold: uint64
	byte 0x7369676e61747572655468726573686f6c64 // "signatureThreshold"
	app_global_get
	!=
	assert

	// src/roles/Attestable.algo.ts:200
	// _oldSignatureThreshold: uint64 = this.signatureThreshold.value
	byte 0x7369676e61747572655468726573686f6c64 // "signatureThreshold"
	app_global_get
	frame_bury 0 // _oldSignatureThreshold: uint64

	// src/roles/Attestable.algo.ts:201
	// this.signatureThreshold.value = newSignatureThreshold
	byte 0x7369676e61747572655468726573686f6c64 // "signatureThreshold"
	frame_dig -1 // newSignatureThreshold: uint64
	app_global_put

	// src/roles/Attestable.algo.ts:203
	// this.SignatureThresholdUpdated.log({ oldSignatureThreshold: _oldSignatureThreshold, newSignatureThreshold: this.signatureThreshold.value })
	byte 0x2a3c3178 // SignatureThresholdUpdated(uint64,uint64)
	frame_dig 0 // _oldSignatureThreshold: uint64
	itob
	byte 0x7369676e61747572655468726573686f6c64 // "signatureThreshold"
	app_global_get
	itob
	concat
	concat
	log
	retsub

// _setAttesterManager(_newAttesterManager: Address): void
//
// @dev Sets a new attester manager address
// @param _newAttesterManager attester manager address to set
_setAttesterManager:
	proto 1 0

	// src/roles/Attestable.algo.ts:213
	// this.attesterManager.value = _newAttesterManager
	byte 0x61747465737465724d616e61676572 // "attesterManager"
	frame_dig -1 // _newAttesterManager: Address
	app_global_put
	retsub

// _isEnabledAttester(attester: bytes32): boolean
//
// @notice returns true if given `attester` is enabled, else false
// @param attester attester to check enabled status of
// @return true if given `attester` is enabled, else false
_isEnabledAttester:
	proto 1 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 3

	// src/roles/Attestable.algo.ts:223
	// assert(attester != bzero(32) as bytes32)
	frame_dig -1 // attester: bytes32
	byte 0x0000000000000000000000000000000000000000000000000000000000000000
	!=
	assert

	// src/roles/Attestable.algo.ts:225
	// boxSize = this.enabledAttesters.size - 2
	byte 0x656e61626c6564417474657374657273 // "enabledAttesters"
	box_len
	assert
	int 2
	-
	frame_bury 0 // boxSize: uint64

	// if2_condition
	// src/roles/Attestable.algo.ts:226
	// boxSize > 0
	frame_dig 0 // boxSize: uint64
	int 0
	>
	bz if2_end

	// if2_consequent
	// src/roles/Attestable.algo.ts:227
	// numAttesters = boxSize / 32
	frame_dig 0 // boxSize: uint64
	int 32
	/
	frame_bury 1 // numAttesters: uint64

	// src/roles/Attestable.algo.ts:228
	// index = 0
	int 0
	frame_bury 2 // index: uint64

while_0:
	// src/roles/Attestable.algo.ts:229
	// index < numAttesters
	frame_dig 2 // index: uint64
	frame_dig 1 // numAttesters: uint64
	<
	bz while_0_end

	// if3_condition
	// src/roles/Attestable.algo.ts:230
	// attester == this.enabledAttesters.value[index]
	frame_dig -1 // attester: bytes32
	byte 0x656e61626c6564417474657374657273 // "enabledAttesters"
	int 2
	int 0
	box_extract
	store 255 // full array
	int 0 // initial offset
	frame_dig 2 // index: uint64
	int 32
	* // acc * typeLength
	+
	load 255 // full array
	swap
	int 32
	extract3
	==
	bz if3_end

	// if3_consequent
	// src/roles/Attestable.algo.ts:231
	// return true;
	int 1

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 2
	retsub

if3_end:
	// src/roles/Attestable.algo.ts:233
	// index = index + 1
	frame_dig 2 // index: uint64
	int 1
	+
	frame_bury 2 // index: uint64
	b while_0

while_0_end:

if2_end:
	// src/roles/Attestable.algo.ts:237
	// return false;
	int 0

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 2
	retsub

// _recoverAttesterSignature(_digest: bytes32, _signature: Signature): bytes32
//
// @notice Checks that signature was signed by attester
// @param _digest message hash
// @param _signature message signature
// @return address of recovered signer
_recoverAttesterSignature:
	proto 2 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 5

	// src/roles/Attestable.algo.ts:250
	// r = btobigint(_signature.r)
	frame_dig -2 // _signature: Signature
	extract 0 32
	frame_bury 0 // r: bigint

	// src/roles/Attestable.algo.ts:251
	// s = btobigint(_signature.s)
	frame_dig -2 // _signature: Signature
	extract 32 32
	frame_bury 1 // s: bigint

	// src/roles/Attestable.algo.ts:252
	// v = _signature.v - 27
	frame_dig -2 // _signature: Signature
	extract 64 1
	btoi
	int 27
	-
	frame_bury 2 // v: unsafe uint8

	// src/roles/Attestable.algo.ts:254
	// res = ecdsa_pk_recover("Secp256k1", _digest, <uint64>v, r, s)
	frame_dig -1 // _digest: bytes32
	frame_dig 2 // v: unsafe uint8
	frame_dig 0 // r: bigint
	frame_dig 1 // s: bigint
	ecdsa_pk_recover Secp256k1
	frame_bury 3 // res: byte[]

	// src/roles/Attestable.algo.ts:255
	// addr = bzero(12) + substring3(keccak256(rawBytes(res)), 12, 32) as bytes32
	byte 0x000000000000000000000000
	frame_dig 3 // res: byte[]
	dup
	len
	itob
	extract 6 2
	swap
	concat
	keccak256
	substring 12 32
	concat
	byte 0x0000000000000000000000000000000000000000000000000000000000000000
	concat
	dup
	extract 32 0
	byte 0x
	b==
	assert
	extract 0 32
	frame_bury 4 // addr: byte[32]

	// src/roles/Attestable.algo.ts:257
	// return addr
	frame_dig 4 // addr: byte[32]

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 4
	retsub

// _verifyAttestationSignatures(_message: bytes, _attestation: bytes): void
//
// @notice reverts if the attestation, which is comprised of one or more concatenated 65-byte signatures, is invalid.
// @dev Rules for valid attestation:
// 1. length of `_attestation` == 65 (signature length) * signatureThreshold
// 2. addresses recovered from attestation must be in increasing order.
// For example, if signature A is signed by address 0x1..., and signature B
// is signed by address 0x2..., attestation must be passed as AB.
// 3. no duplicate signers
// 4. all signers must be enabled attesters
//
// Based on Christian Lundkvist's Simple Multisig
// (https://github.com/christianlundkvist/simple-multisig/tree/560c463c8651e0a4da331bd8f245ccd2a48ab63d)
// @param _message message to verify attestation of
// @param _attestation attestation of `_message`
_verifyAttestationSignatures:
	proto 2 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 6

	// src/roles/Attestable.algo.ts:279
	// assert(_attestation.length === signatureLength * this.signatureThreshold.value)
	frame_dig -2 // _attestation: bytes
	len
	int 65
	byte 0x7369676e61747572655468726573686f6c64 // "signatureThreshold"
	app_global_get
	*
	==
	assert

	// src/roles/Attestable.algo.ts:283
	// _latestAttesterAddress: bytes32 = bzero(32) as bytes32
	byte 0x0000000000000000000000000000000000000000000000000000000000000000
	frame_bury 0 // _latestAttesterAddress: bytes32

	// src/roles/Attestable.algo.ts:285
	// _signatures = castBytes<Signature[]>(_attestation)
	frame_dig -2 // _attestation: bytes
	frame_bury 1 // _signatures: (byte[32],byte[32],uint8)[]

	// src/roles/Attestable.algo.ts:286
	// _digest = keccak256(_message)
	frame_dig -1 // _message: bytes
	keccak256
	frame_bury 2 // _digest: byte[32]

	// src/roles/Attestable.algo.ts:287
	// i = 0
	int 0
	frame_bury 3 // i: uint64

for_1:
	// src/roles/Attestable.algo.ts:287
	// i < this.signatureThreshold.value
	frame_dig 3 // i: uint64
	byte 0x7369676e61747572655468726573686f6c64 // "signatureThreshold"
	app_global_get
	<
	bz for_1_end
	frame_dig 3 // i: uint64
	frame_bury 4 // accessor: accessor//0//_signature

while_1:
	// src/roles/Attestable.algo.ts:291
	// globals.opcodeBudget < 2500
	global OpcodeBudget
	int 2500
	<
	bz while_1_end

	// src/roles/Attestable.algo.ts:292
	// sendAppCall({
	// 					onCompletion: OnCompletion.DeleteApplication,
	// 					approvalProgram: hex("0x0a8101"),
	// 					clearStateProgram: hex("0x0a8101")
	// 				})
	itxn_begin
	int appl
	itxn_field TypeEnum

	// src/roles/Attestable.algo.ts:293
	// onCompletion: OnCompletion.DeleteApplication
	int 5 // DeleteApplication
	itxn_field OnCompletion

	// src/roles/Attestable.algo.ts:294
	// approvalProgram: hex("0x0a8101")
	byte 0x0a8101
	itxn_field ApprovalProgram

	// src/roles/Attestable.algo.ts:295
	// clearStateProgram: hex("0x0a8101")
	byte 0x0a8101
	itxn_field ClearStateProgram

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	b while_1

while_1_end:
	// src/roles/Attestable.algo.ts:300
	// _recoveredAttester: bytes32 = this._recoverAttesterSignature(
	// 				_digest,
	// 				_signature
	// 			)
	frame_dig 1 // _signatures: (byte[32],byte[32],uint8)[]
	store 255 // full array
	int 0 // initial offset
	frame_dig 4 // saved accessor: accessor//0//_signature
	int 65
	* // acc * typeLength
	+
	load 255 // full array
	swap
	int 65
	extract3
	frame_dig 2 // _digest: byte[32]
	callsub _recoverAttesterSignature
	frame_bury 5 // _recoveredAttester: bytes32

	// src/roles/Attestable.algo.ts:306
	// assert(btobigint(_recoveredAttester) > btobigint(_latestAttesterAddress))
	frame_dig 5 // _recoveredAttester: bytes32
	frame_dig 0 // _latestAttesterAddress: bytes32
	b>
	assert

	// src/roles/Attestable.algo.ts:307
	// assert(this._isEnabledAttester(_recoveredAttester))
	frame_dig 5 // _recoveredAttester: bytes32
	callsub _isEnabledAttester
	assert

	// src/roles/Attestable.algo.ts:309
	// _latestAttesterAddress = _recoveredAttester
	frame_dig 5 // _recoveredAttester: bytes32
	frame_bury 0 // _latestAttesterAddress: bytes32

	// src/roles/Attestable.algo.ts:287
	// i = i + 1
	frame_dig 3 // i: uint64
	int 1
	+
	frame_bury 3 // i: uint64
	b for_1

for_1_end:
	retsub

// deploy(uint32,uint64,uint32)void
abi_route_deploy:
	// _version: uint32
	txna ApplicationArgs 3
	dup
	len
	int 4
	==
	assert
	btoi

	// _maxMessageBodySize: uint64
	txna ApplicationArgs 2
	btoi

	// _localDomain: uint32
	txna ApplicationArgs 1
	dup
	len
	int 4
	==
	assert
	btoi

	// execute deploy(uint32,uint64,uint32)void
	callsub deploy
	int 1
	return

// deploy(_localDomain: uint32, _maxMessageBodySize: uint64, _version: uint32): void
deploy:
	proto 3 0

	// src/MessageTransmitter.algo.ts:100
	// this.localDomain.value = _localDomain
	byte 0x6c6f63616c446f6d61696e // "localDomain"
	frame_dig -1 // _localDomain: uint32
	itob
	extract 4 4
	app_global_put

	// src/MessageTransmitter.algo.ts:101
	// this.maxMessageBodySize.value = _maxMessageBodySize
	byte 0x6d61784d657373616765426f647953697a65 // "maxMessageBodySize"
	frame_dig -2 // _maxMessageBodySize: uint64
	app_global_put

	// src/MessageTransmitter.algo.ts:102
	// this.version.value = _version
	byte 0x76657273696f6e // "version"
	frame_dig -3 // _version: uint32
	itob
	extract 4 4
	app_global_put

	// src/MessageTransmitter.algo.ts:105
	// this._transferOwnership(this.txn.sender)
	txn Sender
	callsub _transferOwnership

	// src/MessageTransmitter.algo.ts:108
	// this._setAttesterManager(this.txn.sender)
	txn Sender
	callsub _setAttesterManager

	// src/MessageTransmitter.algo.ts:110
	// this.signatureThreshold.value = 1
	byte 0x7369676e61747572655468726573686f6c64 // "signatureThreshold"
	int 1
	app_global_put
	retsub

// sendMessage(uint32,byte[32],byte[])uint64
abi_route_sendMessage:
	// The ABI return prefix
	byte 0x151f7c75

	// messageBody: byte[]
	txna ApplicationArgs 3
	extract 2 0

	// recipient: byte[32]
	txna ApplicationArgs 2
	dup
	len
	int 32
	==
	assert

	// destinationDomain: uint32
	txna ApplicationArgs 1
	dup
	len
	int 4
	==
	assert
	btoi

	// execute sendMessage(uint32,byte[32],byte[])uint64
	callsub sendMessage
	itob
	concat
	log
	int 1
	return

// sendMessage(destinationDomain: uint32, recipient: bytes32, messageBody: bytes): uint64
//
// Send the message to the destination domain and recipient
//
// @dev Increment nonce, format the message, and emit `MessageSent` event
// with message information.
//
// @param destinationDomain Domain of destination chain
// @param recipient Address of message recipient on destination chain as bytes32
// @param messageBody Raw bytes content of message
// @return nonce reserved by message
sendMessage:
	proto 3 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 3

	// src/MessageTransmitter.algo.ts:132
	// this.whenNotPaused()
	callsub whenNotPaused

	// src/MessageTransmitter.algo.ts:134
	// _emptyDestinationCaller = bzero(32) as bytes32
	byte 0x0000000000000000000000000000000000000000000000000000000000000000
	frame_bury 0 // _emptyDestinationCaller: byte[32]

	// src/MessageTransmitter.algo.ts:135
	// _nonce = this._reserveAndIncrementNonce()
	callsub _reserveAndIncrementNonce
	frame_bury 1 // _nonce: uint64

	// src/MessageTransmitter.algo.ts:136
	// _messageSender = bzero(24) + itob(globals.callerApplicationID) as bytes32
	byte 0x000000000000000000000000000000000000000000000000
	global CallerApplicationID
	itob
	concat
	byte 0x0000000000000000000000000000000000000000000000000000000000000000
	concat
	dup
	extract 32 0
	byte 0x
	b==
	assert
	extract 0 32
	frame_bury 2 // _messageSender: byte[32]

	// src/MessageTransmitter.algo.ts:138
	// this._sendMessage(
	// 			destinationDomain,
	// 			recipient,
	// 			_emptyDestinationCaller,
	// 			_messageSender,
	// 			_nonce,
	// 			messageBody
	// 		)
	frame_dig -3 // messageBody: bytes
	frame_dig 1 // _nonce: uint64
	frame_dig 2 // _messageSender: byte[32]
	frame_dig 0 // _emptyDestinationCaller: byte[32]
	frame_dig -2 // recipient: bytes32
	frame_dig -1 // destinationDomain: uint32
	callsub _sendMessage

	// src/MessageTransmitter.algo.ts:147
	// return _nonce;
	frame_dig 1 // _nonce: uint64

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 2
	retsub

// replaceMessage(byte[],byte[],byte[],byte[32])void
abi_route_replaceMessage:
	// newDestinationCaller: byte[32]
	txna ApplicationArgs 4
	dup
	len
	int 32
	==
	assert

	// newMessageBody: byte[]
	txna ApplicationArgs 3
	extract 2 0

	// originalAttestation: byte[]
	txna ApplicationArgs 2
	extract 2 0

	// originalMessage: byte[]
	txna ApplicationArgs 1
	extract 2 0

	// execute replaceMessage(byte[],byte[],byte[],byte[32])void
	callsub replaceMessage
	int 1
	return

// replaceMessage(originalMessage: bytes, originalAttestation: bytes, newMessageBody: bytes, newDestinationCaller: bytes32): void
//
// Replace a message with a new message body and/or destination caller.
//
// @dev The `originalAttestation` must be a valid attestation of
// `originalMessage`.
// Reverts if msg.sender does not match sender of original message, or if
// the source domain of the original message does not match this
// MessageTransmitter's local domain.
//
// @param originalMessage original message to replace
// @param originalAttestation attestation of `originalMessage`
// @param newMessageBody new message body of replaced message
// @param newDestinationCaller the new destination caller, which may be the
// same as the original destination caller, a new destination caller, or an empty
// destination caller (bytes32(0), indicating that any destination caller is valid.)
replaceMessage:
	proto 4 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 5

	// src/MessageTransmitter.algo.ts:172
	// this.whenNotPaused()
	callsub whenNotPaused

	// src/MessageTransmitter.algo.ts:174
	// this._verifyAttestationSignatures(originalMessage, originalAttestation)
	frame_dig -2 // originalAttestation: bytes
	frame_dig -1 // originalMessage: bytes
	callsub _verifyAttestationSignatures

	// src/MessageTransmitter.algo.ts:176
	// message_start = extractUint16(originalMessage, 0)
	frame_dig -1 // originalMessage: bytes
	int 0
	extract_uint16
	frame_bury 0 // message_start: uint64

	// src/MessageTransmitter.algo.ts:178
	// _message = castBytes<Message>(substring3(originalMessage, message_start, message_start + message_size))
	frame_dig -1 // originalMessage: bytes
	frame_dig 0 // message_start: uint64
	frame_dig 0 // message_start: uint64
	int 116
	+
	substring3
	frame_bury 1 // _message: (uint32,uint32,uint32,uint64,byte[32],byte[32],byte[32])

	// src/MessageTransmitter.algo.ts:181
	// this._validateMessageFormat(_message)
	frame_dig 1 // _message: (uint32,uint32,uint32,uint64,byte[32],byte[32],byte[32])
	callsub _validateMessageFormat

	// src/MessageTransmitter.algo.ts:185
	// assert(bzero(24) + itob(globals.callerApplicationID) as bytes32 === _sender)
	byte 0x000000000000000000000000000000000000000000000000
	global CallerApplicationID
	itob
	concat
	byte 0x0000000000000000000000000000000000000000000000000000000000000000
	concat
	dup
	extract 32 0
	byte 0x
	b==
	assert
	extract 0 32
	frame_dig 1 // _message: (uint32,uint32,uint32,uint64,byte[32],byte[32],byte[32])
	extract 20 32
	==
	assert

	// src/MessageTransmitter.algo.ts:188
	// _sourceDomain = _message._msgSourceDomain
	frame_dig 1 // _message: (uint32,uint32,uint32,uint64,byte[32],byte[32],byte[32])
	extract 4 4
	btoi
	frame_bury 2 // _sourceDomain: uint32

	// src/MessageTransmitter.algo.ts:189
	// assert(_sourceDomain === this.localDomain.value)
	frame_dig 2 // _sourceDomain: uint32
	byte 0x6c6f63616c446f6d61696e // "localDomain"
	app_global_get
	btoi
	==
	assert

	// src/MessageTransmitter.algo.ts:191
	// _destinationDomain = _message._msgDestinationDomain
	frame_dig 1 // _message: (uint32,uint32,uint32,uint64,byte[32],byte[32],byte[32])
	extract 8 4
	btoi
	frame_bury 3 // _destinationDomain: uint32

	// src/MessageTransmitter.algo.ts:193
	// _nonce = _message._msgNonce
	frame_dig 1 // _message: (uint32,uint32,uint32,uint64,byte[32],byte[32],byte[32])
	extract 12 8
	btoi
	frame_bury 4 // _nonce: uint64

	// src/MessageTransmitter.algo.ts:195
	// this._sendMessage(
	// 			_destinationDomain,
	// 			_recipient,
	// 			newDestinationCaller,
	// 			_sender,
	// 			_nonce,
	// 			newMessageBody
	// 		)
	frame_dig -3 // newMessageBody: bytes
	frame_dig 4 // _nonce: uint64
	frame_dig 1 // _message: (uint32,uint32,uint32,uint64,byte[32],byte[32],byte[32])
	extract 20 32
	frame_dig -4 // newDestinationCaller: bytes32
	frame_dig 1 // _message: (uint32,uint32,uint32,uint64,byte[32],byte[32],byte[32])
	extract 52 32
	frame_dig 3 // _destinationDomain: uint32
	callsub _sendMessage
	retsub

// sendMessageWithCaller(uint32,byte[32],byte[32],byte[])uint64
abi_route_sendMessageWithCaller:
	// The ABI return prefix
	byte 0x151f7c75

	// messageBody: byte[]
	txna ApplicationArgs 4
	extract 2 0

	// destinationCaller: byte[32]
	txna ApplicationArgs 3
	dup
	len
	int 32
	==
	assert

	// recipient: byte[32]
	txna ApplicationArgs 2
	dup
	len
	int 32
	==
	assert

	// destinationDomain: uint32
	txna ApplicationArgs 1
	dup
	len
	int 4
	==
	assert
	btoi

	// execute sendMessageWithCaller(uint32,byte[32],byte[32],byte[])uint64
	callsub sendMessageWithCaller
	itob
	concat
	log
	int 1
	return

// sendMessageWithCaller(destinationDomain: uint32, recipient: bytes32, destinationCaller: bytes32, messageBody: bytes): uint64
//
// Send the message to the destination domain and recipient, for a
// specified `destinationCaller` on the destination domain.
//
// @dev Increment nonce, format the message, and emit `MessageSent` event
// with message information.
// WARNING: if the `destinationCaller` does not represent a valid address,
// then it will not be possible to broadcast the message on the destination
// domain. This is an advanced feature, and the standard sendMessage() should
// be preferred for use cases where a specific destination caller is not
// required.
//
// @param destinationDomain Domain of destination chain
// @param recipient Address of message recipient on destination domain as bytes32
// @param destinationCaller caller on the destination domain, as bytes32
// @param messageBody Raw bytes content of message
// @return nonce reserved by message
sendMessageWithCaller:
	proto 4 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dup

	// src/MessageTransmitter.algo.ts:229
	// this.whenNotPaused()
	callsub whenNotPaused

	// src/MessageTransmitter.algo.ts:231
	// assert(destinationCaller != bzero(32) as bytes32)
	frame_dig -3 // destinationCaller: bytes32
	byte 0x0000000000000000000000000000000000000000000000000000000000000000
	!=
	assert

	// src/MessageTransmitter.algo.ts:233
	// _nonce = this._reserveAndIncrementNonce()
	callsub _reserveAndIncrementNonce
	frame_bury 0 // _nonce: uint64

	// src/MessageTransmitter.algo.ts:234
	// _messageSender = (bzero(24) + itob(globals.callerApplicationID)) as bytes32
	byte 0x000000000000000000000000000000000000000000000000
	global CallerApplicationID
	itob
	concat
	byte 0x0000000000000000000000000000000000000000000000000000000000000000
	concat
	dup
	extract 32 0
	byte 0x
	b==
	assert
	extract 0 32
	frame_bury 1 // _messageSender: byte[32]

	// src/MessageTransmitter.algo.ts:236
	// this._sendMessage(
	// 			destinationDomain,
	// 			recipient,
	// 			destinationCaller,
	// 			_messageSender,
	// 			_nonce,
	// 			messageBody
	// 		)
	frame_dig -4 // messageBody: bytes
	frame_dig 0 // _nonce: uint64
	frame_dig 1 // _messageSender: byte[32]
	frame_dig -3 // destinationCaller: bytes32
	frame_dig -2 // recipient: bytes32
	frame_dig -1 // destinationDomain: uint32
	callsub _sendMessage

	// src/MessageTransmitter.algo.ts:245
	// return _nonce;
	frame_dig 0 // _nonce: uint64

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 1
	retsub

// receiveMessage(pay,byte[],byte[])bool
abi_route_receiveMessage:
	// The ABI return prefix
	byte 0x151f7c75

	// attestation: byte[]
	txna ApplicationArgs 2
	extract 2 0

	// message: byte[]
	txna ApplicationArgs 1
	extract 2 0

	// fee: pay
	txn GroupIndex
	int 1
	-
	dup
	gtxns TypeEnum
	int pay
	==
	assert

	// execute receiveMessage(pay,byte[],byte[])bool
	callsub receiveMessage
	byte 0x00
	int 0
	uncover 2
	setbit
	concat
	log
	int 1
	return

// receiveMessage(fee: PayTxn, message: bytes, attestation: bytes): boolean
//
// Receive a message. Messages with a given nonce
// can only be broadcast once for a (sourceDomain, destinationDomain)
// pair. The message body of a valid message is passed to the
// specified recipient for further processing.
//
// @dev Attestation format:
// A valid attestation is the concatenated 65-byte signature(s) of exactly
// `thresholdSignature` signatures, in increasing order of attester address.
// ***If the attester addresses recovered from signatures are not in
// increasing order, signature verification will fail.***
// If incorrect number of signatures or duplicate signatures are supplied,
// signature verification will fail.
//
// Message format:
// Field                 Bytes      Type       Index
// version               4          uint32     0
// sourceDomain          4          uint32     4
// destinationDomain     4          uint32     8
// nonce                 8          uint64     12
// sender                32         bytes32    20
// recipient             32         bytes32    52
// destinationCaller     32         bytes32    84
// messageBody           dynamic    bytes      116
//
// @param message Message bytes
// @param attestation Concatenated 65-byte signature(s) of `message`, in increasing order
// of the attester address recovered from signatures.
// @return success bool, true if successful
receiveMessage:
	proto 3 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 7

	// src/MessageTransmitter.algo.ts:283
	// this.whenNotPaused()
	callsub whenNotPaused

	// src/MessageTransmitter.algo.ts:286
	// verifyPayTxn(fee, {
	// 			receiver: this.app.address,
	// 			amount: (2500) + (400 * (12)),
	// 		})
	// verify receiver
	frame_dig -1 // fee: PayTxn
	gtxns Receiver
	global CurrentApplicationAddress
	==
	assert

	// verify amount
	frame_dig -1 // fee: PayTxn
	gtxns Amount
	int 7300
	==
	assert

	// src/MessageTransmitter.algo.ts:292
	// this._verifyAttestationSignatures(message, attestation)
	frame_dig -3 // attestation: bytes
	frame_dig -2 // message: bytes
	callsub _verifyAttestationSignatures

	// src/MessageTransmitter.algo.ts:294
	// message_start = extractUint16(message, 0)
	frame_dig -2 // message: bytes
	int 0
	extract_uint16
	frame_bury 0 // message_start: uint64

	// src/MessageTransmitter.algo.ts:296
	// _message = castBytes<Message>(substring3(message, message_start, message_start + message_size))
	frame_dig -2 // message: bytes
	frame_dig 0 // message_start: uint64
	frame_dig 0 // message_start: uint64
	int 116
	+
	substring3
	frame_bury 1 // _message: (uint32,uint32,uint32,uint64,byte[32],byte[32],byte[32])

	// src/MessageTransmitter.algo.ts:298
	// msg_body_start = message_start + message_size
	frame_dig 0 // message_start: uint64
	int 116
	+
	frame_bury 2 // msg_body_start: uint64

	// src/MessageTransmitter.algo.ts:299
	// msg_body_size = message.length - msg_body_start
	frame_dig -2 // message: bytes
	len
	frame_dig 2 // msg_body_start: uint64
	-
	frame_bury 3 // msg_body_size: uint64

	// src/MessageTransmitter.algo.ts:300
	// _messageBody = substring3(message, msg_body_start, msg_body_start + msg_body_size)
	frame_dig -2 // message: bytes
	frame_dig 2 // msg_body_start: uint64
	frame_dig 2 // msg_body_start: uint64
	frame_dig 3 // msg_body_size: uint64
	+
	substring3
	frame_bury 4 // _messageBody: byte[]

	// src/MessageTransmitter.algo.ts:303
	// this._validateMessageFormat(_message)
	frame_dig 1 // _message: (uint32,uint32,uint32,uint64,byte[32],byte[32],byte[32])
	callsub _validateMessageFormat

	// src/MessageTransmitter.algo.ts:306
	// assert(_message._msgDestinationDomain === this.localDomain.value)
	frame_dig 1 // _message: (uint32,uint32,uint32,uint64,byte[32],byte[32],byte[32])
	extract 8 4
	btoi
	byte 0x6c6f63616c446f6d61696e // "localDomain"
	app_global_get
	btoi
	==
	assert

	// if4_condition
	// src/MessageTransmitter.algo.ts:309
	// _message._msgDestinationCaller != bzero(32) as bytes32
	frame_dig 1 // _message: (uint32,uint32,uint32,uint64,byte[32],byte[32],byte[32])
	extract 84 32
	byte 0x0000000000000000000000000000000000000000000000000000000000000000
	!=
	bz if4_end

	// if4_consequent
	// src/MessageTransmitter.algo.ts:310
	// assert(_message._msgDestinationCaller === rawBytes(this.txn.sender) as bytes32)
	frame_dig 1 // _message: (uint32,uint32,uint32,uint64,byte[32],byte[32],byte[32])
	extract 84 32
	txn Sender
	byte 0x0000000000000000000000000000000000000000000000000000000000000000
	concat
	dup
	extract 32 0
	byte 0x
	b==
	assert
	extract 0 32
	==
	assert

if4_end:
	// src/MessageTransmitter.algo.ts:314
	// assert(_message._msgVersion === this.version.value)
	frame_dig 1 // _message: (uint32,uint32,uint32,uint64,byte[32],byte[32],byte[32])
	extract 0 4
	btoi
	byte 0x76657273696f6e // "version"
	app_global_get
	btoi
	==
	assert

	// src/MessageTransmitter.algo.ts:319
	// box: SourceDomainNonceBox = {
	// 			sourceDomain: _message._msgSourceDomain,
	// 			nonce: _message._msgNonce
	// 		}
	frame_dig 1 // _message: (uint32,uint32,uint32,uint64,byte[32],byte[32],byte[32])
	extract 4 4
	btoi
	itob
	extract 4 4
	frame_dig 1 // _message: (uint32,uint32,uint32,uint64,byte[32],byte[32],byte[32])
	extract 12 8
	btoi
	itob
	concat
	frame_bury 5 // box: SourceDomainNonceBox

	// src/MessageTransmitter.algo.ts:326
	// assert(!this.usedNonces(box).exists)
	frame_dig 5 // box: SourceDomainNonceBox
	box_len
	swap
	pop
	!
	assert

	// src/MessageTransmitter.algo.ts:327
	// this.usedNonces(box).create(0)
	frame_dig 5 // box: SourceDomainNonceBox
	int 0
	box_create
	pop

	// src/MessageTransmitter.algo.ts:330
	// handled = sendMethodCall<[uint32, bytes32, bytes], boolean>({
	// 			applicationID: Application.fromID(extractUint64(_message._msgRecipient, 24)),
	// 			name: 'handleReceiveMessage',
	// 			methodArgs: [
	// 				_message._msgSourceDomain,
	// 				_message._msgSender,
	// 				_messageBody
	// 			]
	// 		})
	itxn_begin
	int appl
	itxn_field TypeEnum
	method "handleReceiveMessage(uint32,byte[32],byte[])bool"
	itxn_field ApplicationArgs

	// src/MessageTransmitter.algo.ts:331
	// applicationID: Application.fromID(extractUint64(_message._msgRecipient, 24))
	frame_dig 1 // _message: (uint32,uint32,uint32,uint64,byte[32],byte[32],byte[32])
	extract 52 32
	int 24
	extract_uint64
	itxn_field ApplicationID

	// src/MessageTransmitter.algo.ts:333
	// methodArgs: [
	// 				_message._msgSourceDomain,
	// 				_message._msgSender,
	// 				_messageBody
	// 			]
	frame_dig 1 // _message: (uint32,uint32,uint32,uint64,byte[32],byte[32],byte[32])
	extract 4 4
	btoi
	itob
	extract 4 4
	itxn_field ApplicationArgs
	frame_dig 1 // _message: (uint32,uint32,uint32,uint64,byte[32],byte[32],byte[32])
	extract 20 32
	itxn_field ApplicationArgs
	frame_dig 4 // _messageBody: byte[]
	dup
	len
	itob
	extract 6 2
	swap
	concat
	itxn_field ApplicationArgs

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	itxn NumLogs
	int 1
	-
	itxnas Logs
	extract 4 0
	int 0
	getbit
	frame_bury 6 // handled: bool

	// src/MessageTransmitter.algo.ts:341
	// this.MessageReceived.log({
	// 			caller: this.txn.sender,
	// 			sourceDomain: _message._msgSourceDomain,
	// 			nonce: _message._msgNonce,
	// 			sender: _message._msgSender,
	// 			messageBody: _messageBody
	// 		})
	byte 0xe1ad20ff // MessageReceived(address,uint32,uint64,byte[32],byte[])
	byte 0x // initial head
	byte 0x // initial tail
	byte 0x004e // initial head offset
	txn Sender
	callsub process_static_tuple_element
	frame_dig 1 // _message: (uint32,uint32,uint32,uint64,byte[32],byte[32],byte[32])
	extract 4 4
	btoi
	itob
	extract 4 4
	callsub process_static_tuple_element
	frame_dig 1 // _message: (uint32,uint32,uint32,uint64,byte[32],byte[32],byte[32])
	extract 12 8
	btoi
	itob
	callsub process_static_tuple_element
	frame_dig 1 // _message: (uint32,uint32,uint32,uint64,byte[32],byte[32],byte[32])
	extract 20 32
	callsub process_static_tuple_element
	frame_dig 4 // _messageBody: byte[]
	dup
	len
	itob
	extract 6 2
	swap
	concat
	callsub process_dynamic_tuple_element
	pop // pop head offset
	concat // concat head and tail
	concat
	log

	// src/MessageTransmitter.algo.ts:349
	// return true;
	int 1

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 6
	retsub

// setMaxMessageBodySize(uint64)void
abi_route_setMaxMessageBodySize:
	// newMaxMessageBodySize: uint64
	txna ApplicationArgs 1
	btoi

	// execute setMaxMessageBodySize(uint64)void
	callsub setMaxMessageBodySize
	int 1
	return

// setMaxMessageBodySize(newMaxMessageBodySize: uint64): void
//
// Sets the max message body size
//
// @dev This value should not be reduced without good reason,
// to avoid impacting users who rely on large messages.
//
// @param newMaxMessageBodySize new max message body size, in bytes
setMaxMessageBodySize:
	proto 1 0

	// src/MessageTransmitter.algo.ts:363
	// this.onlyOwner()
	callsub onlyOwner

	// src/MessageTransmitter.algo.ts:365
	// this.maxMessageBodySize.value = newMaxMessageBodySize
	byte 0x6d61784d657373616765426f647953697a65 // "maxMessageBodySize"
	frame_dig -1 // newMaxMessageBodySize: uint64
	app_global_put

	// src/MessageTransmitter.algo.ts:367
	// this.MaxMessageBodySizeUpdated.log({ newMaxMessageBodySize: this.maxMessageBodySize.value })
	byte 0x39d67349 // MaxMessageBodySizeUpdated(uint64)
	byte 0x6d61784d657373616765426f647953697a65 // "maxMessageBodySize"
	app_global_get
	itob
	concat
	log
	retsub

// _sendMessage(_destinationDomain: uint32, _recipient: bytes32, _destinationCaller: bytes32, _sender: bytes32, _nonce: uint64, _messageBody: bytes): void
//
// Send the message to the destination domain and recipient. If
// `_destinationCaller` is not equal to bytes32(0), the message can only
// be received on the destination chain when called by `_destinationCaller`.
//
// @dev Format the message and emit `MessageSent` event with message information.
//
// @param _destinationDomain Domain of destination chain
// @param _recipient Address of message recipient on destination domain as bytes32
// @param _destinationCaller caller on the destination domain, as bytes32
// @param _sender message sender, as bytes32
// @param _nonce nonce reserved for message
// @param _messageBody Raw bytes content of message
_sendMessage:
	proto 6 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// src/MessageTransmitter.algo.ts:395
	// assert(_messageBody.length <= this.maxMessageBodySize.value)
	frame_dig -6 // _messageBody: bytes
	len
	byte 0x6d61784d657373616765426f647953697a65 // "maxMessageBodySize"
	app_global_get
	<=
	assert

	// src/MessageTransmitter.algo.ts:397
	// assert(_recipient != bzero(32) as bytes32)
	frame_dig -2 // _recipient: bytes32
	byte 0x0000000000000000000000000000000000000000000000000000000000000000
	!=
	assert

	// src/MessageTransmitter.algo.ts:399
	// _message: Message = {
	// 			_msgVersion: this.version.value,
	// 			_msgSourceDomain: this.localDomain.value,
	// 			_msgDestinationDomain: _destinationDomain,
	// 			_msgNonce: _nonce,
	// 			_msgSender: _sender,
	// 			_msgRecipient: _recipient,
	// 			_msgDestinationCaller: _destinationCaller,
	// 		}
	byte 0x76657273696f6e // "version"
	app_global_get
	btoi
	itob
	extract 4 4
	byte 0x6c6f63616c446f6d61696e // "localDomain"
	app_global_get
	btoi
	itob
	extract 4 4
	concat
	frame_dig -1 // _destinationDomain: uint32
	itob
	extract 4 4
	concat
	frame_dig -5 // _nonce: uint64
	itob
	concat
	frame_dig -4 // _sender: bytes32
	concat
	frame_dig -2 // _recipient: bytes32
	concat
	frame_dig -3 // _destinationCaller: bytes32
	concat
	frame_bury 0 // _message: Message

	// src/MessageTransmitter.algo.ts:410
	// this.MessageSent.log({
	// 			message: rawBytes(_message) + _messageBody
	// 		})
	byte 0x42a65f80 // MessageSent(byte[])
	byte 0x // initial head
	byte 0x // initial tail
	byte 0x0002 // initial head offset
	frame_dig 0 // _message: Message
	frame_dig -6 // _messageBody: bytes
	concat
	dup
	len
	itob
	extract 6 2
	swap
	concat
	callsub process_dynamic_tuple_element
	pop // pop head offset
	concat // concat head and tail
	concat
	log
	retsub

// _validateMessageFormat(_message: Message): void
//
// Reverts if message is incorrect length
//
// @param _message The message
_validateMessageFormat:
	proto 1 0

	// src/MessageTransmitter.algo.ts:421
	// assert(rawBytes(_message).length >= 116)
	frame_dig -1 // _message: Message
	len
	int 116
	>=
	assert
	retsub

// _reserveAndIncrementNonce(): uint64
//
// Reserve and increment next available nonce
//
// @return nonce reserved
_reserveAndIncrementNonce:
	proto 0 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// src/MessageTransmitter.algo.ts:430
	// _nonceReserved: uint64 = this.nextAvailableNonce.value
	byte 0x6e657874417661696c61626c654e6f6e6365 // "nextAvailableNonce"
	app_global_get
	frame_bury 0 // _nonceReserved: uint64

	// src/MessageTransmitter.algo.ts:431
	// this.nextAvailableNonce.value = this.nextAvailableNonce.value + 1
	byte 0x6e657874417661696c61626c654e6f6e6365 // "nextAvailableNonce"
	dup
	app_global_get
	int 1
	+
	app_global_put

	// src/MessageTransmitter.algo.ts:432
	// return _nonceReserved;
	frame_dig 0 // _nonceReserved: uint64

	// set the subroutine return value
	frame_bury 0
	retsub

create_NoOp:
	method "deploy(uint32,uint64,uint32)void"
	txna ApplicationArgs 0
	match abi_route_deploy
	err

call_NoOp:
	method "owner()address"
	method "_checkOwner()void"
	method "transferOwnership(address)void"
	method "pendingOwner()address"
	method "transferOwnership2S(address)void"
	method "acceptOwnership()void"
	method "pauser()address"
	method "pause()void"
	method "unpause()void"
	method "updatePauser(address)void"
	method "enableAttester(byte[32])void"
	method "offsetOfEnabledAttester(byte[32])uint64"
	method "getNumEnabledAttesters()uint64"
	method "updateAttesterManager(address)void"
	method "disableAttester(byte[32])void"
	method "setSignatureThreshold(uint64)void"
	method "sendMessage(uint32,byte[32],byte[])uint64"
	method "replaceMessage(byte[],byte[],byte[],byte[32])void"
	method "sendMessageWithCaller(uint32,byte[32],byte[32],byte[])uint64"
	method "receiveMessage(pay,byte[],byte[])bool"
	method "setMaxMessageBodySize(uint64)void"
	txna ApplicationArgs 0
	match abi_route_owner abi_route__checkOwner abi_route_transferOwnership abi_route_pendingOwner abi_route_transferOwnership2S abi_route_acceptOwnership abi_route_pauser abi_route_pause abi_route_unpause abi_route_updatePauser abi_route_enableAttester abi_route_offsetOfEnabledAttester abi_route_getNumEnabledAttesters abi_route_updateAttesterManager abi_route_disableAttester abi_route_setSignatureThreshold abi_route_sendMessage abi_route_replaceMessage abi_route_sendMessageWithCaller abi_route_receiveMessage abi_route_setMaxMessageBodySize
	err

process_static_tuple_element:
	proto 4 3
	frame_dig -4 // tuple head
	frame_dig -1 // element
	concat
	frame_dig -3 // tuple tail
	frame_dig -2 // head offset
	retsub

process_dynamic_tuple_element:
	proto 4 3
	frame_dig -4 // tuple head
	frame_dig -2 // head offset
	concat
	frame_bury -4 // tuple head
	frame_dig -1 // element
	dup
	len
	frame_dig -2 // head offset
	btoi
	+
	itob
	extract 6 2
	frame_bury -2 // head offset
	frame_dig -3 // tuple tail
	swap
	concat
	frame_bury -3 // tuple tail
	frame_dig -4 // tuple head
	frame_dig -3 // tuple tail
	frame_dig -2 // head offset
	retsub