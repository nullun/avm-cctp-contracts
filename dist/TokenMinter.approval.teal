#pragma version 9

// This TEAL was generated by TEALScript v0.72.1
// https://github.com/algorandfoundation/TEALScript

// This contract is compliant with and/or implements the following ARCs: [ ARC4 ]

// The following ten lines of TEAL handle initial program flow
// This pattern is used to make it easy for anyone to parse the start of the program and determine if a specific action is allowed
// Here, action refers to the OnComplete in combination with whether the app is being created or called
// Every possible action for this contract is represented in the switch statement
// If the action is not implmented in the contract, its respective branch will be "NOT_IMPLEMENTED" which just contains "err"
txn ApplicationID
!
int 6
*
txn OnCompletion
+
switch call_NoOp NOT_IMPLEMENTED NOT_IMPLEMENTED NOT_IMPLEMENTED NOT_IMPLEMENTED NOT_IMPLEMENTED create_NoOp NOT_IMPLEMENTED NOT_IMPLEMENTED NOT_IMPLEMENTED NOT_IMPLEMENTED NOT_IMPLEMENTED

NOT_IMPLEMENTED:
	err

// onlyTokenController()void
//
// @dev Throws if called by any account other than the tokenController.
onlyTokenController:
	proto 0 0

	// src/TokenMinter.algo.ts:99
	// assert(this.txn.sender === this._tokenController.value)
	txn Sender
	byte 0x5f746f6b656e436f6e74726f6c6c6572 // "_tokenController"
	app_global_get
	==
	assert
	retsub

// onlyWithinBurnLimit(uint64,asset)void
//
// @notice ensures that attempted burn does not exceed
// burn limit per-message for given `burnToken`.
// @dev reverts if allowed burn amount is 0, or burnAmount exceeds
// allowed burn amount.
// @param token id of token to burn
// @param amount amount of `token` to burn
onlyWithinBurnLimit:
	proto 2 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// src/TokenMinter.algo.ts:114
	// _allowedBurnAmount: uint<64> = this.burnLimitsPerMessage(token).value
	frame_dig -1 // token: Asset
	itob
	box_get
	assert
	btoi
	frame_bury 0 // _allowedBurnAmount: uint<64>

	// src/TokenMinter.algo.ts:116
	// assert(_allowedBurnAmount)
	frame_dig 0 // _allowedBurnAmount: uint<64>
	assert

	// src/TokenMinter.algo.ts:117
	// assert(amount <= _allowedBurnAmount)
	frame_dig -2 // amount: uint<64>
	frame_dig 0 // _allowedBurnAmount: uint<64>
	<=
	assert
	retsub

// onlyLocalTokenMessenger()void
//
// @notice Only accept messages from the registered message transmitter on local domain
onlyLocalTokenMessenger:
	proto 0 0

	// src/TokenMinter.algo.ts:126
	// assert(this.txn.sender === this.localTokenMessenger.value.address)
	txn Sender
	byte 0x6c6f63616c546f6b656e4d657373656e676572 // "localTokenMessenger"
	app_global_get
	app_params_get AppAddress
	assert
	==
	assert
	retsub

// _setTokenController(address)void
//
// @notice Set tokenController to `newTokenController`, and
// emit `SetTokenController` event.
// @dev newTokenController must be nonzero.
// @param newTokenController address of new token controller
_setTokenController:
	proto 1 0

	// src/TokenMinter.algo.ts:138
	// assert(newTokenController !== globals.zeroAddress)
	frame_dig -1 // newTokenController: Address
	global ZeroAddress
	!=
	assert

	// src/TokenMinter.algo.ts:140
	// this._tokenController.value = newTokenController
	byte 0x5f746f6b656e436f6e74726f6c6c6572 // "_tokenController"
	frame_dig -1 // newTokenController: Address
	app_global_put

	// src/TokenMinter.algo.ts:142
	// this.SetTokenController.log({
	// 			tokenController: newTokenController
	// 		})
	byte 0xa9473940 // SetTokenController(address)
	frame_dig -1 // newTokenController: Address
	concat
	log
	retsub

// _hashRemoteDomainAndToken(byte[32],uint32)byte[32]
//
// @notice hashes packed `_remoteDomain` and `_remoteToken`.
// @param remoteDomain Domain where message originated from
// @param remoteToken Address of remote token as bytes32
// @return keccak hash of packed remote domain and token
_hashRemoteDomainAndToken:
	proto 2 1

	// src/TokenMinter.algo.ts:157
	// return keccak256(concat(rawBytes(remoteDomain), remoteToken)) as bytes32;
	frame_dig -1 // remoteDomain: uint<32>
	itob
	extract 4 4
	frame_dig -2 // remoteToken: bytes32
	concat
	keccak256
	retsub

// _getLocalToken(byte[32],uint32)uint64
//
// @notice Get the enabled local token associated with the given remote domain and token.
// @param remoteDomain Remote domain
// @param remoteToken Remote token
// @return Local asset id
_getLocalToken:
	proto 2 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// src/TokenMinter.algo.ts:170
	// _remoteTokensKey: bytes32 = this._hashRemoteDomainAndToken(
	// 			remoteDomain,
	// 			remoteToken
	// 		)
	frame_dig -2 // remoteToken: bytes32
	frame_dig -1 // remoteDomain: uint<32>
	callsub _hashRemoteDomainAndToken
	frame_bury 0 // _remoteTokensKey: bytes32

	// src/TokenMinter.algo.ts:175
	// return this.remoteTokensToLocalTokens(_remoteTokensKey).value;
	frame_dig 0 // _remoteTokensKey: bytes32
	box_get
	assert
	btoi

	// set the subroutine return value
	frame_bury 0
	retsub

abi_route_linkTokenPair:
	// remoteToken: byte[32]
	txna ApplicationArgs 3
	dup
	len
	int 32
	==
	assert

	// remoteDomain: uint32
	txna ApplicationArgs 2
	dup
	len
	int 4
	==
	assert
	btoi

	// localToken: asset
	txna ApplicationArgs 1
	btoi
	txnas Assets

	// execute linkTokenPair(byte[32],uint32,asset)void
	callsub linkTokenPair
	int 1
	return

// linkTokenPair(byte[32],uint32,asset)void
//
// @notice Links a pair of local and remote tokens to be supported by this TokenMinter.
// @dev Associates a (`remoteToken`, `localToken`) pair by updating remoteTokensToLocalTokens mapping.
// Reverts if the remote token (for the given `remoteDomain`) already maps to a nonzero local token.
// Note:
// - A remote token (on a certain remote domain) can only map to one local token, but many remote tokens
// can map to the same local token.
// - Setting a token pair does not enable the `localToken` (that requires calling setLocalTokenEnabledStatus.)
linkTokenPair:
	proto 3 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// src/TokenMinter.algo.ts:195
	// this.onlyTokenController()
	callsub onlyTokenController

	// src/TokenMinter.algo.ts:198
	// sendAssetTransfer({
	// 			xferAsset: localToken,
	// 			assetReceiver: this.app.address,
	// 			assetAmount: 0
	// 		})
	itxn_begin
	int axfer
	itxn_field TypeEnum

	// src/TokenMinter.algo.ts:199
	// xferAsset: localToken
	frame_dig -1 // localToken: Asset
	itxn_field XferAsset

	// src/TokenMinter.algo.ts:200
	// assetReceiver: this.app.address
	global CurrentApplicationAddress
	itxn_field AssetReceiver

	// src/TokenMinter.algo.ts:201
	// assetAmount: 0
	int 0
	itxn_field AssetAmount

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// src/TokenMinter.algo.ts:204
	// _remoteTokensKey: bytes32 = this._hashRemoteDomainAndToken(
	// 			remoteDomain,
	// 			remoteToken
	// 		)
	frame_dig -3 // remoteToken: bytes32
	frame_dig -2 // remoteDomain: uint<32>
	callsub _hashRemoteDomainAndToken
	frame_bury 0 // _remoteTokensKey: bytes32

	// src/TokenMinter.algo.ts:210
	// assert(!this.remoteTokensToLocalTokens(_remoteTokensKey).exists)
	frame_dig 0 // _remoteTokensKey: bytes32
	box_len
	swap
	pop
	!
	assert

	// src/TokenMinter.algo.ts:212
	// this.remoteTokensToLocalTokens(_remoteTokensKey).value = localToken
	frame_dig 0 // _remoteTokensKey: bytes32
	frame_dig -1 // localToken: Asset
	itob
	box_put

	// src/TokenMinter.algo.ts:214
	// this.TokenPairLinked.log({
	// 			localToken: localToken,
	// 			remoteDomain: remoteDomain,
	// 			remoteToken: remoteToken
	// 		})
	byte 0x20acf370 // TokenPairLinked(uint64,uint32,byte[32])
	frame_dig -1 // localToken: Asset
	itob
	frame_dig -2 // remoteDomain: uint<32>
	itob
	extract 4 4
	concat
	frame_dig -3 // remoteToken: bytes32
	concat
	concat
	log
	retsub

abi_route_unlinkTokenPair:
	// remoteToken: byte[32]
	txna ApplicationArgs 3
	dup
	len
	int 32
	==
	assert

	// remoteDomain: uint32
	txna ApplicationArgs 2
	dup
	len
	int 4
	==
	assert
	btoi

	// localToken: asset
	txna ApplicationArgs 1
	btoi
	txnas Assets

	// execute unlinkTokenPair(byte[32],uint32,asset)void
	callsub unlinkTokenPair
	int 1
	return

// unlinkTokenPair(byte[32],uint32,asset)void
//
// @notice Unlinks a pair of local and remote tokens for this TokenMinter.
// @dev Removes link from `remoteToken`, to `localToken` for given `remoteDomain`
// by updating remoteTokensToLocalTokens mapping.
// Reverts if the remote token (for the given `remoteDomain`) already maps to the zero address.
// Note:
// - A remote token (on a certain remote domain) can only map to one local token, but many remote tokens
// can map to the same local token.
// - Unlinking a token pair does not disable burning the `localToken` (that requires calling setMaxBurnAmountPerMessage.)
unlinkTokenPair:
	proto 3 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// src/TokenMinter.algo.ts:236
	// this.onlyTokenController()
	callsub onlyTokenController

	// src/TokenMinter.algo.ts:240
	// _remoteTokensKey: bytes32 = this._hashRemoteDomainAndToken(
	// 			remoteDomain,
	// 			remoteToken
	// 		)
	frame_dig -3 // remoteToken: bytes32
	frame_dig -2 // remoteDomain: uint<32>
	callsub _hashRemoteDomainAndToken
	frame_bury 0 // _remoteTokensKey: bytes32

	// src/TokenMinter.algo.ts:246
	// assert(this.remoteTokensToLocalTokens(_remoteTokensKey).exists)
	frame_dig 0 // _remoteTokensKey: bytes32
	box_len
	swap
	pop
	assert

	// src/TokenMinter.algo.ts:248
	// this.remoteTokensToLocalTokens(_remoteTokensKey).delete()
	frame_dig 0 // _remoteTokensKey: bytes32
	box_del

	// src/TokenMinter.algo.ts:250
	// this.TokenPairUnlinked.log({
	// 			localToken: localToken,
	// 			remoteDomain: remoteDomain,
	// 			remoteToken: remoteToken
	// 		})
	byte 0x704abd38 // TokenPairUnlinked(uint64,uint32,byte[32])
	frame_dig -1 // localToken: Asset
	itob
	frame_dig -2 // remoteDomain: uint<32>
	itob
	extract 4 4
	concat
	frame_dig -3 // remoteToken: bytes32
	concat
	concat
	log
	retsub

abi_route_setMaxBurnAmountPerMessage:
	// burnLimitPerMessage: uint64
	txna ApplicationArgs 2
	btoi

	// localToken: asset
	txna ApplicationArgs 1
	btoi
	txnas Assets

	// execute setMaxBurnAmountPerMessage(uint64,asset)void
	callsub setMaxBurnAmountPerMessage
	int 1
	return

// setMaxBurnAmountPerMessage(uint64,asset)void
//
// @notice Sets the maximum burn amount per message for a given `localToken`.
// @dev Burns with amounts exceeding `burnLimitPerMessage` will revert. Mints do not
// respect this value, so if this limit is reduced, previously burned tokens will still
// be mintable.
// @param localToken Local token to set the maximum burn amount per message of.
// @param burnLimitPerMessage Maximum burn amount per message to set.
setMaxBurnAmountPerMessage:
	proto 2 0

	// src/TokenMinter.algo.ts:269
	// this.onlyTokenController()
	callsub onlyTokenController

	// src/TokenMinter.algo.ts:271
	// this.burnLimitsPerMessage(localToken).value = burnLimitPerMessage
	frame_dig -1 // localToken: Asset
	itob
	frame_dig -2 // burnLimitPerMessage: uint<64>
	itob
	box_put

	// src/TokenMinter.algo.ts:273
	// this.SetBurnLimitPerMessage.log({
	// 			token: localToken,
	// 			burnLimitPerMessage: burnLimitPerMessage
	// 		})
	byte 0x59034c5f // SetBurnLimitPerMessage(uint64,uint64)
	frame_dig -1 // localToken: Asset
	itob
	frame_dig -2 // burnLimitPerMessage: uint<64>
	itob
	concat
	concat
	log
	retsub

abi_route_mint:
	// The ABI return prefix
	byte 0x151f7c75

	// amount: uint64
	txna ApplicationArgs 4
	btoi

	// to: address
	txna ApplicationArgs 3
	dup
	len
	int 32
	==
	assert

	// burnToken: byte[32]
	txna ApplicationArgs 2
	dup
	len
	int 32
	==
	assert

	// sourceDomain: uint32
	txna ApplicationArgs 1
	dup
	len
	int 4
	==
	assert
	btoi

	// execute mint(uint64,address,byte[32],uint32)uint64
	callsub mint
	itob
	concat
	log
	int 1
	return

// mint(uint64,address,byte[32],uint32)uint64
//
// @notice Mints `amount` of local tokens corresponding to the
// given (`sourceDomain`, `burnToken`) pair, to `to` address.
// @dev reverts if the (`sourceDomain`, `burnToken`) pair does not
// map to a nonzero local token address. This mapping can be queried using
// getLocalToken().
// @param sourceDomain Source domain where `burnToken` was burned.
// @param burnToken Burned token address as bytes32.
// @param to Address to receive minted tokens, corresponding to `burnToken`,
// on this domain.
// @param amount Amount of tokens to mint. Must be less than or equal
// to the minterAllowance of this TokenMinter for given `_mintToken`.
// @return mintToken token minted.
mint:
	proto 4 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// src/TokenMinter.algo.ts:301
	// this.onlyLocalTokenMessenger()
	callsub onlyLocalTokenMessenger

	// src/TokenMinter.algo.ts:303
	// _mintToken: Asset = this._getLocalToken(sourceDomain, burnToken)
	frame_dig -2 // burnToken: bytes32
	frame_dig -1 // sourceDomain: uint<32>
	callsub _getLocalToken
	frame_bury 0 // _mintToken: Asset

	// src/TokenMinter.algo.ts:304
	// assert(_mintToken)
	frame_dig 0 // _mintToken: Asset
	assert

	// src/TokenMinter.algo.ts:307
	// sendAssetTransfer({
	// 			xferAsset: _mintToken,
	// 			assetReceiver: to,
	// 			assetAmount: amount
	// 		})
	itxn_begin
	int axfer
	itxn_field TypeEnum

	// src/TokenMinter.algo.ts:308
	// xferAsset: _mintToken
	frame_dig 0 // _mintToken: Asset
	itxn_field XferAsset

	// src/TokenMinter.algo.ts:309
	// assetReceiver: to
	frame_dig -3 // to: Address
	itxn_field AssetReceiver

	// src/TokenMinter.algo.ts:310
	// assetAmount: amount
	frame_dig -4 // amount: uint<64>
	itxn_field AssetAmount

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// src/TokenMinter.algo.ts:313
	// return _mintToken;
	frame_dig 0 // _mintToken: Asset

	// set the subroutine return value
	frame_bury 0
	retsub

abi_route_burn:
	// burnAmount: uint64
	txna ApplicationArgs 2
	btoi

	// burnToken: asset
	txna ApplicationArgs 1
	btoi
	txnas Assets

	// execute burn(uint64,asset)void
	callsub burn
	int 1
	return

// burn(uint64,asset)void
//
// @notice Burn tokens owned by this TokenMinter.
// @param burnToken burnable token id.
// @param burnAmount amount of tokens to burn. Must be
// > 0, and <= maximum burn amount per message.
burn:
	proto 2 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// src/TokenMinter.algo.ts:327
	// this.onlyLocalTokenMessenger()
	callsub onlyLocalTokenMessenger

	// src/TokenMinter.algo.ts:328
	// this.onlyWithinBurnLimit(burnToken, burnAmount)
	frame_dig -2 // burnAmount: uint<64>
	frame_dig -1 // burnToken: Asset
	callsub onlyWithinBurnLimit

	// src/TokenMinter.algo.ts:330
	// reserveAddress: Address = burnToken.reserve
	frame_dig -1 // burnToken: Asset
	asset_params_get AssetReserve
	assert
	frame_bury 0 // reserveAddress: Address

	// src/TokenMinter.algo.ts:333
	// sendAssetTransfer({
	// 			xferAsset: burnToken,
	// 			assetReceiver: reserveAddress,
	// 			assetAmount: burnAmount
	// 		})
	itxn_begin
	int axfer
	itxn_field TypeEnum

	// src/TokenMinter.algo.ts:334
	// xferAsset: burnToken
	frame_dig -1 // burnToken: Asset
	itxn_field XferAsset

	// src/TokenMinter.algo.ts:335
	// assetReceiver: reserveAddress
	frame_dig 0 // reserveAddress: Address
	itxn_field AssetReceiver

	// src/TokenMinter.algo.ts:336
	// assetAmount: burnAmount
	frame_dig -2 // burnAmount: uint<64>
	itxn_field AssetAmount

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	retsub

abi_route_addLocalTokenMessenger:
	// newLocalTokenMessenger: application
	txna ApplicationArgs 1
	btoi
	txnas Applications

	// execute addLocalTokenMessenger(application)void
	callsub addLocalTokenMessenger
	int 1
	return

// addLocalTokenMessenger(application)void
//
// @notice Add TokenMessenger for the local domain. Only this TokenMessenger
// has permission to call mint() and burn() on this TokenMinter.
// @dev Reverts if a TokenMessenger is already set for the local domain.
// @param newLocalTokenMessenger The address of the new TokenMessenger on the local domain.
addLocalTokenMessenger:
	proto 1 0

	// src/TokenMinter.algo.ts:351
	// assert(newLocalTokenMessenger)
	frame_dig -1 // newLocalTokenMessenger: Application
	assert

	// src/TokenMinter.algo.ts:352
	// assert(!this.localTokenMessenger.exists)
	txna Applications 0
	byte 0x6c6f63616c546f6b656e4d657373656e676572 // "localTokenMessenger"
	app_global_get_ex
	swap
	pop
	!
	assert

	// src/TokenMinter.algo.ts:354
	// this.localTokenMessenger.value = newLocalTokenMessenger
	byte 0x6c6f63616c546f6b656e4d657373656e676572 // "localTokenMessenger"
	frame_dig -1 // newLocalTokenMessenger: Application
	app_global_put

	// src/TokenMinter.algo.ts:356
	// this.LocalTokenMessengerAdded.log({
	// 			localTokenMessenger: newLocalTokenMessenger
	// 		})
	byte 0x5ca790b1 // LocalTokenMessengerAdded(uint64)
	frame_dig -1 // newLocalTokenMessenger: Application
	itob
	concat
	log
	retsub

abi_route_removeLocalTokenMessenger:
	// execute removeLocalTokenMessenger()void
	callsub removeLocalTokenMessenger
	int 1
	return

// removeLocalTokenMessenger()void
//
// @notice Remove the TokenMessenger for the local domain.
// @dev Reverts if the TokenMessenger of the local domain is not set.
removeLocalTokenMessenger:
	proto 0 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// src/TokenMinter.algo.ts:368
	// assert(this.localTokenMessenger.exists)
	txna Applications 0
	byte 0x6c6f63616c546f6b656e4d657373656e676572 // "localTokenMessenger"
	app_global_get_ex
	swap
	pop
	assert

	// src/TokenMinter.algo.ts:370
	// _localTokenMessengerBeforeRemoval: Application = this.localTokenMessenger.value
	byte 0x6c6f63616c546f6b656e4d657373656e676572 // "localTokenMessenger"
	app_global_get
	frame_bury 0 // _localTokenMessengerBeforeRemoval: Application

	// src/TokenMinter.algo.ts:372
	// this.localTokenMessenger.delete()
	byte 0x6c6f63616c546f6b656e4d657373656e676572 // "localTokenMessenger"
	app_global_del

	// src/TokenMinter.algo.ts:374
	// this.LocalTokenMessengerRemoved.log({
	// 			localTokenMessenger: _localTokenMessengerBeforeRemoval
	// 		})
	byte 0xc49b7820 // LocalTokenMessengerRemoved(uint64)
	frame_dig 0 // _localTokenMessengerBeforeRemoval: Application
	itob
	concat
	log
	retsub

abi_route_setTokenController:
	// newTokenController: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// execute setTokenController(address)void
	callsub setTokenController
	int 1
	return

// setTokenController(address)void
//
// @notice Set tokenController to `newTokenController`, and
// emit `SetTokenController` event.
// @dev newTokenController must be nonzero.
// @param newTokenController address of new token controller
setTokenController:
	proto 1 0

	// src/TokenMinter.algo.ts:390
	// this._setTokenController(newTokenController)
	frame_dig -1 // newTokenController: Address
	callsub _setTokenController
	retsub

abi_route_getLocalToken:
	// The ABI return prefix
	byte 0x151f7c75

	// remoteToken: byte[32]
	txna ApplicationArgs 2
	dup
	len
	int 32
	==
	assert

	// remoteDomain: uint32
	txna ApplicationArgs 1
	dup
	len
	int 4
	==
	assert
	btoi

	// execute getLocalToken(byte[32],uint32)uint64
	callsub getLocalToken
	itob
	concat
	log
	int 1
	return

// getLocalToken(byte[32],uint32)uint64
//
// @notice Get the local token id associated with the given
// remote domain and token.
// @param remoteDomain Remote domain
// @param remoteToken Remote token
// @return local token id
getLocalToken:
	proto 2 1

	// src/TokenMinter.algo.ts:404
	// return this._getLocalToken(remoteDomain, remoteToken);
	frame_dig -2 // remoteToken: bytes32
	frame_dig -1 // remoteDomain: uint<32>
	callsub _getLocalToken
	retsub

abi_route_deploy:
	// _tokenController: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// execute deploy(address)void
	callsub deploy
	int 1
	return

// deploy(address)void
//
// @param _tokenController Token controller address
deploy:
	proto 1 0

	// src/TokenMinter.algo.ts:414
	// this._setTokenController(_tokenController)
	frame_dig -1 // _tokenController: Address
	callsub _setTokenController
	retsub

create_NoOp:
	method "deploy(address)void"
	txna ApplicationArgs 0
	match abi_route_deploy
	err

call_NoOp:
	method "linkTokenPair(asset,uint32,byte[32])void"
	method "unlinkTokenPair(asset,uint32,byte[32])void"
	method "setMaxBurnAmountPerMessage(asset,uint64)void"
	method "mint(uint32,byte[32],address,uint64)uint64"
	method "burn(asset,uint64)void"
	method "addLocalTokenMessenger(application)void"
	method "removeLocalTokenMessenger()void"
	method "setTokenController(address)void"
	method "getLocalToken(uint32,byte[32])uint64"
	txna ApplicationArgs 0
	match abi_route_linkTokenPair abi_route_unlinkTokenPair abi_route_setMaxBurnAmountPerMessage abi_route_mint abi_route_burn abi_route_addLocalTokenMessenger abi_route_removeLocalTokenMessenger abi_route_setTokenController abi_route_getLocalToken
	err