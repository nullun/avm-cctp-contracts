#pragma version 10

// This TEAL was generated by TEALScript v0.73.3
// https://github.com/algorandfoundation/TEALScript

// This contract is compliant with and/or implements the following ARCs: [ ARC4 ]

// The following ten lines of TEAL handle initial program flow
// This pattern is used to make it easy for anyone to parse the start of the program and determine if a specific action is allowed
// Here, action refers to the OnComplete in combination with whether the app is being created or called
// Every possible action for this contract is represented in the switch statement
// If the action is not implmented in the contract, its respective branch will be "NOT_IMPLEMENTED" which just contains "err"
txn ApplicationID
!
int 6
*
txn OnCompletion
+
switch call_NoOp NOT_IMPLEMENTED NOT_IMPLEMENTED NOT_IMPLEMENTED NOT_IMPLEMENTED NOT_IMPLEMENTED create_NoOp NOT_IMPLEMENTED NOT_IMPLEMENTED NOT_IMPLEMENTED NOT_IMPLEMENTED NOT_IMPLEMENTED

NOT_IMPLEMENTED:
	err

// onlyTokenController()void
//
// @dev Throws if called by any account other than the tokenController.
onlyTokenController:
	proto 0 0

	// src/roles/TokenController.algo.ts:75
	// assert(this.txn.sender === this._tokenController.value)
	txn Sender
	byte 0x5f746f6b656e436f6e74726f6c6c6572 // "_tokenController"
	app_global_get
	==
	assert
	retsub

// onlyWithinBurnLimit(uint64,asset)void
//
// @notice ensures that attempted burn does not exceed
// burn limit per-message for given `burnToken`.
// @dev reverts if allowed burn amount is 0, or burnAmount exceeds
// allowed burn amount.
// @param token id of token to burn
// @param amount amount of `token` to burn
onlyWithinBurnLimit:
	proto 2 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// src/roles/TokenController.algo.ts:90
	// _allowedBurnAmount: uint<64> = this.burnLimitsPerMessage(token).value
	frame_dig -1 // token: Asset
	itob
	box_get
	assert
	btoi
	frame_bury 0 // _allowedBurnAmount: uint<64>

	// src/roles/TokenController.algo.ts:92
	// assert(_allowedBurnAmount)
	frame_dig 0 // _allowedBurnAmount: uint<64>
	assert

	// src/roles/TokenController.algo.ts:93
	// assert(amount <= _allowedBurnAmount)
	frame_dig -2 // amount: uint<64>
	frame_dig 0 // _allowedBurnAmount: uint<64>
	<=
	assert
	retsub

abi_route_tokenController:
	// The ABI return prefix
	byte 0x151f7c75

	// execute tokenController()address
	callsub tokenController
	concat
	log
	int 1
	return

// tokenController()address
//
// @dev Returns the address of the tokenController
// @return address of the tokenController
tokenController:
	proto 0 1

	// src/roles/TokenController.algo.ts:104
	// return this._tokenController.value;
	byte 0x5f746f6b656e436f6e74726f6c6c6572 // "_tokenController"
	app_global_get
	retsub

abi_route_linkTokenPair:
	// remoteToken: byte[32]
	txna ApplicationArgs 3
	dup
	len
	int 32
	==
	assert

	// remoteDomain: uint32
	txna ApplicationArgs 2
	dup
	len
	int 4
	==
	assert
	btoi

	// localToken: asset
	txna ApplicationArgs 1
	btoi
	txnas Assets

	// execute linkTokenPair(byte[32],uint32,asset)void
	callsub linkTokenPair
	int 1
	return

// linkTokenPair(byte[32],uint32,asset)void
//
// @notice Links a pair of local and remote tokens to be supported by this TokenMinter.
// @dev Associates a (`remoteToken`, `localToken`) pair by updating remoteTokensToLocalTokens mapping.
// Reverts if the remote token (for the given `remoteDomain`) already maps to a nonzero local token.
// Note:
// - A remote token (on a certain remote domain) can only map to one local token, but many remote tokens
// can map to the same local token.
// - Setting a token pair does not enable the `localToken` (that requires calling setLocalTokenEnabledStatus.)
linkTokenPair:
	proto 3 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// src/roles/TokenController.algo.ts:123
	// this.onlyTokenController()
	callsub onlyTokenController

	// src/roles/TokenController.algo.ts:126
	// sendAssetTransfer({
	// 			xferAsset: localToken,
	// 			assetReceiver: this.app.address,
	// 			assetAmount: 0
	// 		})
	itxn_begin
	int axfer
	itxn_field TypeEnum

	// src/roles/TokenController.algo.ts:127
	// xferAsset: localToken
	frame_dig -1 // localToken: Asset
	itxn_field XferAsset

	// src/roles/TokenController.algo.ts:128
	// assetReceiver: this.app.address
	global CurrentApplicationAddress
	itxn_field AssetReceiver

	// src/roles/TokenController.algo.ts:129
	// assetAmount: 0
	int 0
	itxn_field AssetAmount

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// src/roles/TokenController.algo.ts:132
	// _remoteTokensKey: bytes32 = this._hashRemoteDomainAndToken(
	// 			remoteDomain,
	// 			remoteToken
	// 		)
	frame_dig -3 // remoteToken: bytes32
	frame_dig -2 // remoteDomain: uint<32>
	callsub _hashRemoteDomainAndToken
	frame_bury 0 // _remoteTokensKey: bytes32

	// src/roles/TokenController.algo.ts:138
	// assert(!this.remoteTokensToLocalTokens(_remoteTokensKey).exists)
	frame_dig 0 // _remoteTokensKey: bytes32
	box_len
	swap
	pop
	!
	assert

	// src/roles/TokenController.algo.ts:140
	// this.remoteTokensToLocalTokens(_remoteTokensKey).value = localToken
	frame_dig 0 // _remoteTokensKey: bytes32
	frame_dig -1 // localToken: Asset
	itob
	box_put

	// src/roles/TokenController.algo.ts:142
	// this.TokenPairLinked.log({
	// 			localToken: localToken,
	// 			remoteDomain: remoteDomain,
	// 			remoteToken: remoteToken
	// 		})
	byte 0x20acf370 // TokenPairLinked(uint64,uint32,byte[32])
	frame_dig -1 // localToken: Asset
	itob
	frame_dig -2 // remoteDomain: uint<32>
	itob
	extract 4 4
	concat
	frame_dig -3 // remoteToken: bytes32
	concat
	concat
	log
	retsub

abi_route_unlinkTokenPair:
	// remoteToken: byte[32]
	txna ApplicationArgs 3
	dup
	len
	int 32
	==
	assert

	// remoteDomain: uint32
	txna ApplicationArgs 2
	dup
	len
	int 4
	==
	assert
	btoi

	// localToken: asset
	txna ApplicationArgs 1
	btoi
	txnas Assets

	// execute unlinkTokenPair(byte[32],uint32,asset)void
	callsub unlinkTokenPair
	int 1
	return

// unlinkTokenPair(byte[32],uint32,asset)void
//
// @notice Unlinks a pair of local and remote tokens for this TokenMinter.
// @dev Removes link from `remoteToken`, to `localToken` for given `remoteDomain`
// by updating remoteTokensToLocalTokens mapping.
// Reverts if the remote token (for the given `remoteDomain`) already maps to the zero address.
// Note:
// - A remote token (on a certain remote domain) can only map to one local token, but many remote tokens
// can map to the same local token.
// - Unlinking a token pair does not disable burning the `localToken` (that requires calling setMaxBurnAmountPerMessage.)
unlinkTokenPair:
	proto 3 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// src/roles/TokenController.algo.ts:164
	// this.onlyTokenController()
	callsub onlyTokenController

	// src/roles/TokenController.algo.ts:168
	// _remoteTokensKey: bytes32 = this._hashRemoteDomainAndToken(
	// 			remoteDomain,
	// 			remoteToken
	// 		)
	frame_dig -3 // remoteToken: bytes32
	frame_dig -2 // remoteDomain: uint<32>
	callsub _hashRemoteDomainAndToken
	frame_bury 0 // _remoteTokensKey: bytes32

	// src/roles/TokenController.algo.ts:174
	// assert(this.remoteTokensToLocalTokens(_remoteTokensKey).exists)
	frame_dig 0 // _remoteTokensKey: bytes32
	box_len
	swap
	pop
	assert

	// src/roles/TokenController.algo.ts:176
	// this.remoteTokensToLocalTokens(_remoteTokensKey).delete()
	frame_dig 0 // _remoteTokensKey: bytes32
	box_del

	// src/roles/TokenController.algo.ts:178
	// this.TokenPairUnlinked.log({
	// 			localToken: localToken,
	// 			remoteDomain: remoteDomain,
	// 			remoteToken: remoteToken
	// 		})
	byte 0x704abd38 // TokenPairUnlinked(uint64,uint32,byte[32])
	frame_dig -1 // localToken: Asset
	itob
	frame_dig -2 // remoteDomain: uint<32>
	itob
	extract 4 4
	concat
	frame_dig -3 // remoteToken: bytes32
	concat
	concat
	log
	retsub

abi_route_setMaxBurnAmountPerMessage:
	// burnLimitPerMessage: uint64
	txna ApplicationArgs 2
	btoi

	// localToken: asset
	txna ApplicationArgs 1
	btoi
	txnas Assets

	// execute setMaxBurnAmountPerMessage(uint64,asset)void
	callsub setMaxBurnAmountPerMessage
	int 1
	return

// setMaxBurnAmountPerMessage(uint64,asset)void
//
// @notice Sets the maximum burn amount per message for a given `localToken`.
// @dev Burns with amounts exceeding `burnLimitPerMessage` will revert. Mints do not
// respect this value, so if this limit is reduced, previously burned tokens will still
// be mintable.
// @param localToken Local token to set the maximum burn amount per message of.
// @param burnLimitPerMessage Maximum burn amount per message to set.
setMaxBurnAmountPerMessage:
	proto 2 0

	// src/roles/TokenController.algo.ts:197
	// this.onlyTokenController()
	callsub onlyTokenController

	// src/roles/TokenController.algo.ts:199
	// this.burnLimitsPerMessage(localToken).value = burnLimitPerMessage
	frame_dig -1 // localToken: Asset
	itob
	frame_dig -2 // burnLimitPerMessage: uint<64>
	itob
	box_put

	// src/roles/TokenController.algo.ts:201
	// this.SetBurnLimitPerMessage.log({
	// 			token: localToken,
	// 			burnLimitPerMessage: burnLimitPerMessage
	// 		})
	byte 0x59034c5f // SetBurnLimitPerMessage(uint64,uint64)
	frame_dig -1 // localToken: Asset
	itob
	frame_dig -2 // burnLimitPerMessage: uint<64>
	itob
	concat
	concat
	log
	retsub

// _setTokenController(address)void
//
// @notice Set tokenController to `newTokenController`, and
// emit `SetTokenController` event.
// @dev newTokenController must be nonzero.
// @param newTokenController address of new token controller
_setTokenController:
	proto 1 0

	// src/roles/TokenController.algo.ts:216
	// assert(newTokenController !== globals.zeroAddress)
	frame_dig -1 // newTokenController: Address
	global ZeroAddress
	!=
	assert

	// src/roles/TokenController.algo.ts:218
	// this._tokenController.value = newTokenController
	byte 0x5f746f6b656e436f6e74726f6c6c6572 // "_tokenController"
	frame_dig -1 // newTokenController: Address
	app_global_put

	// src/roles/TokenController.algo.ts:220
	// this.SetTokenController.log({
	// 			tokenController: newTokenController
	// 		})
	byte 0xa9473940 // SetTokenController(address)
	frame_dig -1 // newTokenController: Address
	concat
	log
	retsub

// _getLocalToken(byte[32],uint32)uint64
//
// @notice Get the enabled local token associated with the given remote domain and token.
// @param remoteDomain Remote domain
// @param remoteToken Remote token
// @return Local asset id
_getLocalToken:
	proto 2 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// src/roles/TokenController.algo.ts:235
	// _remoteTokensKey: bytes32 = this._hashRemoteDomainAndToken(
	// 			remoteDomain,
	// 			remoteToken
	// 		)
	frame_dig -2 // remoteToken: bytes32
	frame_dig -1 // remoteDomain: uint<32>
	callsub _hashRemoteDomainAndToken
	frame_bury 0 // _remoteTokensKey: bytes32

	// src/roles/TokenController.algo.ts:240
	// return this.remoteTokensToLocalTokens(_remoteTokensKey).value;
	frame_dig 0 // _remoteTokensKey: bytes32
	box_get
	assert
	btoi

	// set the subroutine return value
	frame_bury 0
	retsub

// _hashRemoteDomainAndToken(byte[32],uint32)byte[32]
//
// @notice hashes packed `_remoteDomain` and `_remoteToken`.
// @param remoteDomain Domain where message originated from
// @param remoteToken Address of remote token as bytes32
// @return keccak hash of packed remote domain and token
_hashRemoteDomainAndToken:
	proto 2 1

	// src/roles/TokenController.algo.ts:253
	// return keccak256(concat(rawBytes(remoteDomain), remoteToken)) as bytes32;
	frame_dig -1 // remoteDomain: uint<32>
	itob
	extract 4 4
	frame_dig -2 // remoteToken: bytes32
	concat
	keccak256
	retsub

// onlyOwner()void
//
// @dev Throws if called by any account other than the owner.
onlyOwner:
	proto 0 0

	// src/roles/Ownable.algo.ts:29
	// assert(this.txn.sender === this._owner.value)
	txn Sender
	byte 0x5f6f776e6572 // "_owner"
	app_global_get
	==
	assert
	retsub

abi_route_owner:
	// The ABI return prefix
	byte 0x151f7c75

	// execute owner()address
	callsub owner
	concat
	log
	int 1
	return

// owner()address
//
// @dev Returns the address of the current owner.
owner:
	proto 0 1

	// src/roles/Ownable.algo.ts:39
	// return this._owner.value;
	byte 0x5f6f776e6572 // "_owner"
	app_global_get
	retsub

abi_route__checkOwner:
	// execute _checkOwner()void
	callsub _checkOwner
	int 1
	return

// _checkOwner()void
//
// @dev Throws if the sender is not the owner.
_checkOwner:
	proto 0 0

	// src/roles/Ownable.algo.ts:47
	// assert(this.owner() == this.txn.sender)
	callsub owner
	txn Sender
	==
	assert
	retsub

abi_route_transferOwnership:
	// newOwner: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// execute transferOwnership(address)void
	callsub transferOwnership
	int 1
	return

// transferOwnership(address)void
//
// @dev Transfers ownership of the application to a new account (`newOwner`).
// Can only be called by the current owner.
transferOwnership:
	proto 1 0

	// src/roles/Ownable.algo.ts:57
	// this.onlyOwner()
	callsub onlyOwner

	// src/roles/Ownable.algo.ts:59
	// assert(newOwner != globals.zeroAddress)
	frame_dig -1 // newOwner: Address
	global ZeroAddress
	!=
	assert

	// src/roles/Ownable.algo.ts:61
	// this._transferOwnership(newOwner)
	frame_dig -1 // newOwner: Address
	callsub _transferOwnership
	retsub

// _transferOwnership(address)void
//
// @dev Transfers ownership of the application to a new account (`newOwner`).
// Internal function without access restriction.
_transferOwnership:
	proto 1 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// src/roles/Ownable.algo.ts:71
	// oldOwner: Address = this._owner.exists ? this._owner.value : globals.zeroAddress
	txna Applications 0
	byte 0x5f6f776e6572 // "_owner"
	app_global_get_ex
	swap
	pop
	bz ternary1_false
	byte 0x5f6f776e6572 // "_owner"
	app_global_get
	b ternary1_end

ternary1_false:
	global ZeroAddress

ternary1_end:
	frame_bury 0 // oldOwner: Address

	// src/roles/Ownable.algo.ts:72
	// this._owner.value = newOwner
	byte 0x5f6f776e6572 // "_owner"
	frame_dig -1 // newOwner: Address
	app_global_put

	// src/roles/Ownable.algo.ts:74
	// this.OwnershipTransferred.log({ oldAddress: oldOwner, newAddress: newOwner })
	byte 0x9a223efb // OwnershipTransferred(address,address)
	frame_dig 0 // oldOwner: Address
	frame_dig -1 // newOwner: Address
	concat
	concat
	log
	retsub

abi_route_pendingOwner:
	// The ABI return prefix
	byte 0x151f7c75

	// execute pendingOwner()address
	callsub pendingOwner
	concat
	log
	int 1
	return

// pendingOwner()address
//
// @dev Returns the address of the pending owner.
pendingOwner:
	proto 0 1

	// src/roles/Ownable2Step.algo.ts:28
	// return this._pendingOwner.value;
	byte 0x5f70656e64696e674f776e6572 // "_pendingOwner"
	app_global_get
	retsub

abi_route_transferOwnership2S:
	// newOwner: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// execute transferOwnership2S(address)void
	callsub transferOwnership2S
	int 1
	return

// transferOwnership2S(address)void
//
// @dev Starts the ownership transfer of the contract to a new account. Replaces the pending transfer if there is one.
// Can only be called by the current owner.
// FIX: Once overrides exist, rename to transferOwnership
transferOwnership2S:
	proto 1 0

	// src/roles/Ownable2Step.algo.ts:39
	// this.onlyOwner()
	callsub onlyOwner

	// src/roles/Ownable2Step.algo.ts:41
	// this._pendingOwner.value = newOwner
	byte 0x5f70656e64696e674f776e6572 // "_pendingOwner"
	frame_dig -1 // newOwner: Address
	app_global_put

	// src/roles/Ownable2Step.algo.ts:43
	// this.OwnershipTransferStarted.log({
	//             previousAddress: this._owner.value,
	//             newAddress: newOwner
	//         })
	byte 0x2424ff2a // OwnershipTransferStarted(address,address)
	byte 0x5f6f776e6572 // "_owner"
	app_global_get
	frame_dig -1 // newOwner: Address
	concat
	concat
	log
	retsub

abi_route_acceptOwnership:
	// execute acceptOwnership()void
	callsub acceptOwnership
	int 1
	return

// acceptOwnership()void
//
// @dev The new owner accepts the ownership transfer.
acceptOwnership:
	proto 0 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// src/roles/Ownable2Step.algo.ts:53
	// sender: Address = this.txn.sender
	txn Sender
	frame_bury 0 // sender: Address

	// src/roles/Ownable2Step.algo.ts:54
	// assert(this.pendingOwner() == sender)
	callsub pendingOwner
	frame_dig 0 // sender: Address
	==
	assert

	// src/roles/Ownable2Step.algo.ts:56
	// this._transferOwnership2S(sender)
	frame_dig 0 // sender: Address
	callsub _transferOwnership2S
	retsub

// _transferOwnership2S(address)void
//
// @dev Transfers ownership of the contract to a new account (`newOwner`) and deletes any pending owner.
// Internal function without access restriction.
// FIX: Once overrides exist, rename to _transferOwnership
_transferOwnership2S:
	proto 1 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// src/roles/Ownable2Step.algo.ts:67
	// oldOwner: Address = this._owner.exists ? this._owner.value : globals.zeroAddress
	txna Applications 0
	byte 0x5f6f776e6572 // "_owner"
	app_global_get_ex
	swap
	pop
	bz ternary3_false
	byte 0x5f6f776e6572 // "_owner"
	app_global_get
	b ternary3_end

ternary3_false:
	global ZeroAddress

ternary3_end:
	frame_bury 0 // oldOwner: Address

	// src/roles/Ownable2Step.algo.ts:68
	// this._owner.value = newOwner
	byte 0x5f6f776e6572 // "_owner"
	frame_dig -1 // newOwner: Address
	app_global_put

	// src/roles/Ownable2Step.algo.ts:70
	// this.OwnershipTransferred.log({ oldAddress: oldOwner, newAddress: newOwner })
	byte 0x9a223efb // OwnershipTransferred(address,address)
	frame_dig 0 // oldOwner: Address
	frame_dig -1 // newOwner: Address
	concat
	concat
	log
	retsub

// whenNotPaused()void
//
// @dev Modifier to make a function callable only when the contract is not paused.
whenNotPaused:
	proto 0 0

	// src/roles/Pausable.algo.ts:25
	// assert(!this.paused.value)
	byte 0x706175736564 // "paused"
	app_global_get
	int 0
	getbit
	!
	assert
	retsub

// onlyPauser()void
//
// @dev throws if called by any account other than the pauser
onlyPauser:
	proto 0 0

	// src/roles/Pausable.algo.ts:32
	// assert(this.txn.sender === this._pauser.value)
	txn Sender
	byte 0x5f706175736572 // "_pauser"
	app_global_get
	==
	assert
	retsub

abi_route_pauser:
	// The ABI return prefix
	byte 0x151f7c75

	// execute pauser()address
	callsub pauser
	concat
	log
	int 1
	return

// pauser()address
//
// @notice Returns current pauser
// @return Pauser's address
pauser:
	proto 0 1

	// src/roles/Pausable.algo.ts:42
	// return this._pauser.value;
	byte 0x5f706175736572 // "_pauser"
	app_global_get
	retsub

abi_route_pause:
	// execute pause()void
	callsub pause
	int 1
	return

// pause()void
//
// @dev called by the owner to pause, triggers stopped state
pause:
	proto 0 0

	// src/roles/Pausable.algo.ts:51
	// this.onlyPauser()
	callsub onlyPauser

	// src/roles/Pausable.algo.ts:53
	// this.paused.value = true
	byte 0x706175736564 // "paused"
	int 1
	byte 0x00
	int 0
	uncover 2
	setbit
	app_global_put

	// src/roles/Pausable.algo.ts:54
	// this.Pause.log({})
	byte 0xcf23a30f // Pause()
	concat
	log
	retsub

abi_route_unpause:
	// execute unpause()void
	callsub unpause
	int 1
	return

// unpause()void
//
// @dev called by the owner to unpause, returns to normal state
unpause:
	proto 0 0

	// src/roles/Pausable.algo.ts:61
	// this.onlyPauser()
	callsub onlyPauser

	// src/roles/Pausable.algo.ts:63
	// this.paused.value = false
	byte 0x706175736564 // "paused"
	int 0
	byte 0x00
	int 0
	uncover 2
	setbit
	app_global_put

	// src/roles/Pausable.algo.ts:64
	// this.Unpause.log({})
	byte 0xb163ee0b // Unpause()
	concat
	log
	retsub

abi_route_updatePauser:
	// _newPauser: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// execute updatePauser(address)void
	callsub updatePauser
	int 1
	return

// updatePauser(address)void
//
// @dev update the pauser role
updatePauser:
	proto 1 0

	// src/roles/Pausable.algo.ts:71
	// this.onlyPauser()
	callsub onlyPauser

	// src/roles/Pausable.algo.ts:73
	// assert(_newPauser != globals.zeroAddress)
	frame_dig -1 // _newPauser: Address
	global ZeroAddress
	!=
	assert

	// src/roles/Pausable.algo.ts:74
	// this._pauser.value = _newPauser
	byte 0x5f706175736572 // "_pauser"
	frame_dig -1 // _newPauser: Address
	app_global_put

	// src/roles/Pausable.algo.ts:75
	// this.PauserChanged.log({ newAddress: this._pauser.value })
	byte 0xcc40923c // PauserChanged(address)
	byte 0x5f706175736572 // "_pauser"
	app_global_get
	concat
	log
	retsub

abi_route_deploy:
	// _tokenController: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// execute deploy(address)void
	callsub deploy
	int 1
	return

// deploy(address)void
//
// @param _tokenController Token controller address
deploy:
	proto 1 0

	// src/TokenMinter.algo.ts:42
	// this._transferOwnership(this.txn.sender)
	txn Sender
	callsub _transferOwnership

	// src/TokenMinter.algo.ts:45
	// this._setTokenController(_tokenController)
	frame_dig -1 // _tokenController: Address
	callsub _setTokenController
	retsub

// onlyLocalTokenMessenger()void
//
// @notice Only accept messages from the registered message transmitter on local domain
onlyLocalTokenMessenger:
	proto 0 0

	// src/TokenMinter.algo.ts:55
	// assert(this.txn.sender === this.localTokenMessenger.value.address)
	txn Sender
	byte 0x6c6f63616c546f6b656e4d657373656e676572 // "localTokenMessenger"
	app_global_get
	app_params_get AppAddress
	assert
	==
	assert
	retsub

abi_route_mint:
	// The ABI return prefix
	byte 0x151f7c75

	// amount: uint64
	txna ApplicationArgs 4
	btoi

	// to: address
	txna ApplicationArgs 3
	dup
	len
	int 32
	==
	assert

	// burnToken: byte[32]
	txna ApplicationArgs 2
	dup
	len
	int 32
	==
	assert

	// sourceDomain: uint32
	txna ApplicationArgs 1
	dup
	len
	int 4
	==
	assert
	btoi

	// execute mint(uint64,address,byte[32],uint32)uint64
	callsub mint
	itob
	concat
	log
	int 1
	return

// mint(uint64,address,byte[32],uint32)uint64
//
// @notice Mints `amount` of local tokens corresponding to the
// given (`sourceDomain`, `burnToken`) pair, to `to` address.
// @dev reverts if the (`sourceDomain`, `burnToken`) pair does not
// map to a nonzero local token address. This mapping can be queried using
// getLocalToken().
// @param sourceDomain Source domain where `burnToken` was burned.
// @param burnToken Burned token address as bytes32.
// @param to Address to receive minted tokens, corresponding to `burnToken`,
// on this domain.
// @param amount Amount of tokens to mint. Must be less than or equal
// to the minterAllowance of this TokenMinter for given `_mintToken`.
// @return mintToken token minted.
mint:
	proto 4 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// src/TokenMinter.algo.ts:83
	// this.whenNotPaused()
	callsub whenNotPaused

	// src/TokenMinter.algo.ts:84
	// this.onlyLocalTokenMessenger()
	callsub onlyLocalTokenMessenger

	// src/TokenMinter.algo.ts:86
	// _mintToken: Asset = this._getLocalToken(sourceDomain, burnToken)
	frame_dig -2 // burnToken: bytes32
	frame_dig -1 // sourceDomain: uint<32>
	callsub _getLocalToken
	frame_bury 0 // _mintToken: Asset

	// src/TokenMinter.algo.ts:87
	// assert(_mintToken)
	frame_dig 0 // _mintToken: Asset
	assert

	// src/TokenMinter.algo.ts:90
	// sendAssetTransfer({
	// 			xferAsset: _mintToken,
	// 			assetReceiver: to,
	// 			assetAmount: amount
	// 		})
	itxn_begin
	int axfer
	itxn_field TypeEnum

	// src/TokenMinter.algo.ts:91
	// xferAsset: _mintToken
	frame_dig 0 // _mintToken: Asset
	itxn_field XferAsset

	// src/TokenMinter.algo.ts:92
	// assetReceiver: to
	frame_dig -3 // to: Address
	itxn_field AssetReceiver

	// src/TokenMinter.algo.ts:93
	// assetAmount: amount
	frame_dig -4 // amount: uint<64>
	itxn_field AssetAmount

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// src/TokenMinter.algo.ts:96
	// return _mintToken;
	frame_dig 0 // _mintToken: Asset

	// set the subroutine return value
	frame_bury 0
	retsub

abi_route_burn:
	// burnAmount: uint64
	txna ApplicationArgs 2
	btoi

	// burnToken: asset
	txna ApplicationArgs 1
	btoi
	txnas Assets

	// execute burn(uint64,asset)void
	callsub burn
	int 1
	return

// burn(uint64,asset)void
//
// @notice Burn tokens owned by this TokenMinter.
// @param burnToken burnable token id.
// @param burnAmount amount of tokens to burn. Must be
// > 0, and <= maximum burn amount per message.
burn:
	proto 2 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// src/TokenMinter.algo.ts:109
	// this.whenNotPaused()
	callsub whenNotPaused

	// src/TokenMinter.algo.ts:110
	// this.onlyLocalTokenMessenger()
	callsub onlyLocalTokenMessenger

	// src/TokenMinter.algo.ts:111
	// this.onlyWithinBurnLimit(burnToken, burnAmount)
	frame_dig -2 // burnAmount: uint<64>
	frame_dig -1 // burnToken: Asset
	callsub onlyWithinBurnLimit

	// src/TokenMinter.algo.ts:113
	// reserveAddress: Address = burnToken.reserve
	frame_dig -1 // burnToken: Asset
	asset_params_get AssetReserve
	assert
	frame_bury 0 // reserveAddress: Address

	// src/TokenMinter.algo.ts:116
	// sendAssetTransfer({
	// 			xferAsset: burnToken,
	// 			assetReceiver: reserveAddress,
	// 			assetAmount: burnAmount
	// 		})
	itxn_begin
	int axfer
	itxn_field TypeEnum

	// src/TokenMinter.algo.ts:117
	// xferAsset: burnToken
	frame_dig -1 // burnToken: Asset
	itxn_field XferAsset

	// src/TokenMinter.algo.ts:118
	// assetReceiver: reserveAddress
	frame_dig 0 // reserveAddress: Address
	itxn_field AssetReceiver

	// src/TokenMinter.algo.ts:119
	// assetAmount: burnAmount
	frame_dig -2 // burnAmount: uint<64>
	itxn_field AssetAmount

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	retsub

abi_route_addLocalTokenMessenger:
	// newLocalTokenMessenger: application
	txna ApplicationArgs 1
	btoi
	txnas Applications

	// execute addLocalTokenMessenger(application)void
	callsub addLocalTokenMessenger
	int 1
	return

// addLocalTokenMessenger(application)void
//
// @notice Add TokenMessenger for the local domain. Only this TokenMessenger
// has permission to call mint() and burn() on this TokenMinter.
// @dev Reverts if a TokenMessenger is already set for the local domain.
// @param newLocalTokenMessenger The address of the new TokenMessenger on the local domain.
addLocalTokenMessenger:
	proto 1 0

	// src/TokenMinter.algo.ts:132
	// this.onlyOwner()
	callsub onlyOwner

	// src/TokenMinter.algo.ts:134
	// assert(newLocalTokenMessenger)
	frame_dig -1 // newLocalTokenMessenger: Application
	assert

	// src/TokenMinter.algo.ts:135
	// assert(!this.localTokenMessenger.exists)
	txna Applications 0
	byte 0x6c6f63616c546f6b656e4d657373656e676572 // "localTokenMessenger"
	app_global_get_ex
	swap
	pop
	!
	assert

	// src/TokenMinter.algo.ts:137
	// this.localTokenMessenger.value = newLocalTokenMessenger
	byte 0x6c6f63616c546f6b656e4d657373656e676572 // "localTokenMessenger"
	frame_dig -1 // newLocalTokenMessenger: Application
	app_global_put

	// src/TokenMinter.algo.ts:139
	// this.LocalTokenMessengerAdded.log({
	// 			localTokenMessenger: newLocalTokenMessenger
	// 		})
	byte 0x5ca790b1 // LocalTokenMessengerAdded(uint64)
	frame_dig -1 // newLocalTokenMessenger: Application
	itob
	concat
	log
	retsub

abi_route_removeLocalTokenMessenger:
	// execute removeLocalTokenMessenger()void
	callsub removeLocalTokenMessenger
	int 1
	return

// removeLocalTokenMessenger()void
//
// @notice Remove the TokenMessenger for the local domain.
// @dev Reverts if the TokenMessenger of the local domain is not set.
removeLocalTokenMessenger:
	proto 0 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// src/TokenMinter.algo.ts:149
	// this.onlyOwner()
	callsub onlyOwner

	// src/TokenMinter.algo.ts:151
	// assert(this.localTokenMessenger.exists)
	txna Applications 0
	byte 0x6c6f63616c546f6b656e4d657373656e676572 // "localTokenMessenger"
	app_global_get_ex
	swap
	pop
	assert

	// src/TokenMinter.algo.ts:153
	// _localTokenMessengerBeforeRemoval: Application = this.localTokenMessenger.value
	byte 0x6c6f63616c546f6b656e4d657373656e676572 // "localTokenMessenger"
	app_global_get
	frame_bury 0 // _localTokenMessengerBeforeRemoval: Application

	// src/TokenMinter.algo.ts:155
	// this.localTokenMessenger.delete()
	byte 0x6c6f63616c546f6b656e4d657373656e676572 // "localTokenMessenger"
	app_global_del

	// src/TokenMinter.algo.ts:157
	// this.LocalTokenMessengerRemoved.log({
	// 			localTokenMessenger: _localTokenMessengerBeforeRemoval
	// 		})
	byte 0xc49b7820 // LocalTokenMessengerRemoved(uint64)
	frame_dig 0 // _localTokenMessengerBeforeRemoval: Application
	itob
	concat
	log
	retsub

abi_route_setTokenController:
	// newTokenController: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// execute setTokenController(address)void
	callsub setTokenController
	int 1
	return

// setTokenController(address)void
//
// @notice Set tokenController to `newTokenController`, and
// emit `SetTokenController` event.
// @dev newTokenController must be nonzero.
// @param newTokenController address of new token controller
setTokenController:
	proto 1 0

	// src/TokenMinter.algo.ts:171
	// this.onlyOwner()
	callsub onlyOwner

	// src/TokenMinter.algo.ts:173
	// this._setTokenController(newTokenController)
	frame_dig -1 // newTokenController: Address
	callsub _setTokenController
	retsub

abi_route_getLocalToken:
	// The ABI return prefix
	byte 0x151f7c75

	// remoteToken: byte[32]
	txna ApplicationArgs 2
	dup
	len
	int 32
	==
	assert

	// remoteDomain: uint32
	txna ApplicationArgs 1
	dup
	len
	int 4
	==
	assert
	btoi

	// execute getLocalToken(byte[32],uint32)uint64
	callsub getLocalToken
	itob
	concat
	log
	int 1
	return

// getLocalToken(byte[32],uint32)uint64
//
// @notice Get the local token id associated with the given
// remote domain and token.
// @param remoteDomain Remote domain
// @param remoteToken Remote token
// @return local token id
getLocalToken:
	proto 2 1

	// src/TokenMinter.algo.ts:187
	// return this._getLocalToken(remoteDomain, remoteToken);
	frame_dig -2 // remoteToken: bytes32
	frame_dig -1 // remoteDomain: uint<32>
	callsub _getLocalToken
	retsub

create_NoOp:
	method "deploy(address)void"
	txna ApplicationArgs 0
	match abi_route_deploy
	err

call_NoOp:
	method "tokenController()address"
	method "linkTokenPair(asset,uint32,byte[32])void"
	method "unlinkTokenPair(asset,uint32,byte[32])void"
	method "setMaxBurnAmountPerMessage(asset,uint64)void"
	method "owner()address"
	method "_checkOwner()void"
	method "transferOwnership(address)void"
	method "pendingOwner()address"
	method "transferOwnership2S(address)void"
	method "acceptOwnership()void"
	method "pauser()address"
	method "pause()void"
	method "unpause()void"
	method "updatePauser(address)void"
	method "mint(uint32,byte[32],address,uint64)uint64"
	method "burn(asset,uint64)void"
	method "addLocalTokenMessenger(application)void"
	method "removeLocalTokenMessenger()void"
	method "setTokenController(address)void"
	method "getLocalToken(uint32,byte[32])uint64"
	txna ApplicationArgs 0
	match abi_route_tokenController abi_route_linkTokenPair abi_route_unlinkTokenPair abi_route_setMaxBurnAmountPerMessage abi_route_owner abi_route__checkOwner abi_route_transferOwnership abi_route_pendingOwner abi_route_transferOwnership2S abi_route_acceptOwnership abi_route_pauser abi_route_pause abi_route_unpause abi_route_updatePauser abi_route_mint abi_route_burn abi_route_addLocalTokenMessenger abi_route_removeLocalTokenMessenger abi_route_setTokenController abi_route_getLocalToken
	err