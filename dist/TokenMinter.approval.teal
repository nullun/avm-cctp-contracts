#pragma version 10

// This TEAL was generated by TEALScript v0.79.0
// https://github.com/algorandfoundation/TEALScript

// This contract is compliant with and/or implements the following ARCs: [ ARC4 ]

// The following ten lines of TEAL handle initial program flow
// This pattern is used to make it easy for anyone to parse the start of the program and determine if a specific action is allowed
// Here, action refers to the OnComplete in combination with whether the app is being created or called
// Every possible action for this contract is represented in the switch statement
// If the action is not implmented in the contract, its respective branch will be "NOT_IMPLEMENTED" which just contains "err"
txn ApplicationID
!
int 6
*
txn OnCompletion
+
switch call_NoOp NOT_IMPLEMENTED NOT_IMPLEMENTED NOT_IMPLEMENTED NOT_IMPLEMENTED NOT_IMPLEMENTED create_NoOp NOT_IMPLEMENTED NOT_IMPLEMENTED NOT_IMPLEMENTED NOT_IMPLEMENTED NOT_IMPLEMENTED

NOT_IMPLEMENTED:
	err

// onlyTokenController(): void
//
// @dev Throws if called by any account other than the tokenController.
onlyTokenController:
	proto 0 0

	// src/roles/TokenController.algo.ts:94
	// assert(this.txn.sender === this._tokenController.value)
	txn Sender
	byte 0x5f746f6b656e436f6e74726f6c6c6572 // "_tokenController"
	app_global_get
	==
	assert
	retsub

// onlyWithinBurnLimit(token: Asset, amount: uint64): void
//
// @notice ensures that attempted burn does not exceed
// burn limit per-message for given `burnToken`.
// @dev reverts if allowed burn amount is 0, or burnAmount exceeds
// allowed burn amount.
// @param token id of token to burn
// @param amount amount of `token` to burn
onlyWithinBurnLimit:
	proto 2 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// src/roles/TokenController.algo.ts:109
	// _allowedBurnAmount: uint64 = this.burnLimitsPerMessage(token).value
	frame_dig -1 // token: Asset
	itob
	box_get
	assert
	btoi
	frame_bury 0 // _allowedBurnAmount: uint64

	// src/roles/TokenController.algo.ts:111
	// assert(_allowedBurnAmount)
	frame_dig 0 // _allowedBurnAmount: uint64
	assert

	// src/roles/TokenController.algo.ts:112
	// assert(amount <= _allowedBurnAmount)
	frame_dig -2 // amount: uint64
	frame_dig 0 // _allowedBurnAmount: uint64
	<=
	assert
	retsub

// tokenController()address
abi_route_tokenController:
	// The ABI return prefix
	byte 0x151f7c75

	// execute tokenController()address
	callsub tokenController
	concat
	log
	int 1
	return

// tokenController(): Address
//
// @dev Returns the address of the tokenController
// @return address of the tokenController
tokenController:
	proto 0 1

	// src/roles/TokenController.algo.ts:123
	// return this._tokenController.value;
	byte 0x5f746f6b656e436f6e74726f6c6c6572 // "_tokenController"
	app_global_get
	retsub

// linkTokenPair(asset,uint32,byte[32])void
abi_route_linkTokenPair:
	// remoteToken: byte[32]
	txna ApplicationArgs 3
	dup
	len
	int 32
	==
	assert

	// remoteDomain: uint32
	txna ApplicationArgs 2
	dup
	len
	int 4
	==
	assert
	btoi

	// localToken: asset
	txna ApplicationArgs 1
	btoi
	txnas Assets

	// execute linkTokenPair(asset,uint32,byte[32])void
	callsub linkTokenPair
	int 1
	return

// linkTokenPair(localToken: Asset, remoteDomain: uint32, remoteToken: bytes32): void
//
// @notice Links a pair of local and remote tokens to be supported by this TokenMinter.
// @dev Associates a (`remoteToken`, `localToken`) pair by updating remoteTokensToLocalTokens mapping.
// Reverts if the remote token (for the given `remoteDomain`) already maps to a nonzero local token.
// Note:
// - A remote token (on a certain remote domain) can only map to one local token, but many remote tokens
// can map to the same local token.
// - Setting a token pair does not enable the `localToken` (that requires calling setLocalTokenEnabledStatus.)
linkTokenPair:
	proto 3 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// src/roles/TokenController.algo.ts:142
	// this.onlyTokenController()
	callsub onlyTokenController

	// src/roles/TokenController.algo.ts:145
	// sendAssetTransfer({
	// 			xferAsset: localToken,
	// 			assetReceiver: this.app.address,
	// 			assetAmount: 0
	// 		})
	itxn_begin
	int axfer
	itxn_field TypeEnum

	// src/roles/TokenController.algo.ts:146
	// xferAsset: localToken
	frame_dig -1 // localToken: Asset
	itxn_field XferAsset

	// src/roles/TokenController.algo.ts:147
	// assetReceiver: this.app.address
	global CurrentApplicationAddress
	itxn_field AssetReceiver

	// src/roles/TokenController.algo.ts:148
	// assetAmount: 0
	int 0
	itxn_field AssetAmount

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// src/roles/TokenController.algo.ts:151
	// _remoteTokensKey: bytes32 = this._hashRemoteDomainAndToken(
	// 			remoteDomain,
	// 			remoteToken
	// 		)
	frame_dig -3 // remoteToken: bytes32
	frame_dig -2 // remoteDomain: uint32
	callsub _hashRemoteDomainAndToken
	frame_bury 0 // _remoteTokensKey: bytes32

	// src/roles/TokenController.algo.ts:157
	// assert(!this.remoteTokensToLocalTokens(_remoteTokensKey).exists)
	frame_dig 0 // _remoteTokensKey: bytes32
	box_len
	swap
	pop
	!
	assert

	// src/roles/TokenController.algo.ts:159
	// this.remoteTokensToLocalTokens(_remoteTokensKey).value = localToken
	frame_dig 0 // _remoteTokensKey: bytes32
	frame_dig -1 // localToken: Asset
	itob
	box_put

	// src/roles/TokenController.algo.ts:161
	// this.TokenPairLinked.log({
	// 			localToken: localToken,
	// 			remoteDomain: remoteDomain,
	// 			remoteToken: remoteToken
	// 		})
	byte 0x20acf370 // TokenPairLinked(uint64,uint32,byte[32])
	frame_dig -1 // localToken: Asset
	itob
	frame_dig -2 // remoteDomain: uint32
	itob
	extract 4 4
	concat
	frame_dig -3 // remoteToken: bytes32
	concat
	concat
	log
	retsub

// unlinkTokenPair(asset,uint32,byte[32])void
abi_route_unlinkTokenPair:
	// remoteToken: byte[32]
	txna ApplicationArgs 3
	dup
	len
	int 32
	==
	assert

	// remoteDomain: uint32
	txna ApplicationArgs 2
	dup
	len
	int 4
	==
	assert
	btoi

	// localToken: asset
	txna ApplicationArgs 1
	btoi
	txnas Assets

	// execute unlinkTokenPair(asset,uint32,byte[32])void
	callsub unlinkTokenPair
	int 1
	return

// unlinkTokenPair(localToken: Asset, remoteDomain: uint32, remoteToken: bytes32): void
//
// @notice Unlinks a pair of local and remote tokens for this TokenMinter.
// @dev Removes link from `remoteToken`, to `localToken` for given `remoteDomain`
// by updating remoteTokensToLocalTokens mapping.
// Reverts if the remote token (for the given `remoteDomain`) already maps to the zero address.
// Note:
// - A remote token (on a certain remote domain) can only map to one local token, but many remote tokens
// can map to the same local token.
// - Unlinking a token pair does not disable burning the `localToken` (that requires calling setMaxBurnAmountPerMessage.)
unlinkTokenPair:
	proto 3 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// src/roles/TokenController.algo.ts:183
	// this.onlyTokenController()
	callsub onlyTokenController

	// src/roles/TokenController.algo.ts:187
	// _remoteTokensKey: bytes32 = this._hashRemoteDomainAndToken(
	// 			remoteDomain,
	// 			remoteToken
	// 		)
	frame_dig -3 // remoteToken: bytes32
	frame_dig -2 // remoteDomain: uint32
	callsub _hashRemoteDomainAndToken
	frame_bury 0 // _remoteTokensKey: bytes32

	// src/roles/TokenController.algo.ts:193
	// assert(this.remoteTokensToLocalTokens(_remoteTokensKey).exists)
	frame_dig 0 // _remoteTokensKey: bytes32
	box_len
	swap
	pop
	assert

	// src/roles/TokenController.algo.ts:195
	// this.remoteTokensToLocalTokens(_remoteTokensKey).delete()
	frame_dig 0 // _remoteTokensKey: bytes32
	box_del

	// src/roles/TokenController.algo.ts:197
	// this.TokenPairUnlinked.log({
	// 			localToken: localToken,
	// 			remoteDomain: remoteDomain,
	// 			remoteToken: remoteToken
	// 		})
	byte 0x704abd38 // TokenPairUnlinked(uint64,uint32,byte[32])
	frame_dig -1 // localToken: Asset
	itob
	frame_dig -2 // remoteDomain: uint32
	itob
	extract 4 4
	concat
	frame_dig -3 // remoteToken: bytes32
	concat
	concat
	log
	retsub

// setMaxBurnAmountPerMessage(asset,uint64)void
abi_route_setMaxBurnAmountPerMessage:
	// burnLimitPerMessage: uint64
	txna ApplicationArgs 2
	btoi

	// localToken: asset
	txna ApplicationArgs 1
	btoi
	txnas Assets

	// execute setMaxBurnAmountPerMessage(asset,uint64)void
	callsub setMaxBurnAmountPerMessage
	int 1
	return

// setMaxBurnAmountPerMessage(localToken: Asset, burnLimitPerMessage: uint64): void
//
// @notice Sets the maximum burn amount per message for a given `localToken`.
// @dev Burns with amounts exceeding `burnLimitPerMessage` will revert. Mints do not
// respect this value, so if this limit is reduced, previously burned tokens will still
// be mintable.
// @param localToken Local token to set the maximum burn amount per message of.
// @param burnLimitPerMessage Maximum burn amount per message to set.
setMaxBurnAmountPerMessage:
	proto 2 0

	// src/roles/TokenController.algo.ts:216
	// this.onlyTokenController()
	callsub onlyTokenController

	// src/roles/TokenController.algo.ts:218
	// this.burnLimitsPerMessage(localToken).value = burnLimitPerMessage
	frame_dig -1 // localToken: Asset
	itob
	frame_dig -2 // burnLimitPerMessage: uint64
	itob
	box_put

	// src/roles/TokenController.algo.ts:220
	// this.SetBurnLimitPerMessage.log({
	// 			token: localToken,
	// 			burnLimitPerMessage: burnLimitPerMessage
	// 		})
	byte 0x59034c5f // SetBurnLimitPerMessage(uint64,uint64)
	frame_dig -1 // localToken: Asset
	itob
	frame_dig -2 // burnLimitPerMessage: uint64
	itob
	concat
	concat
	log
	retsub

// _setTokenController(newTokenController: Address): void
//
// @notice Set tokenController to `newTokenController`, and
// emit `SetTokenController` event.
// @dev newTokenController must be nonzero.
// @param newTokenController address of new token controller
_setTokenController:
	proto 1 0

	// src/roles/TokenController.algo.ts:235
	// assert(newTokenController !== globals.zeroAddress)
	frame_dig -1 // newTokenController: Address
	global ZeroAddress
	!=
	assert

	// src/roles/TokenController.algo.ts:237
	// this._tokenController.value = newTokenController
	byte 0x5f746f6b656e436f6e74726f6c6c6572 // "_tokenController"
	frame_dig -1 // newTokenController: Address
	app_global_put

	// src/roles/TokenController.algo.ts:239
	// this.SetTokenController.log({
	// 			tokenController: newTokenController
	// 		})
	byte 0xa9473940 // SetTokenController(address)
	frame_dig -1 // newTokenController: Address
	concat
	log
	retsub

// _getLocalToken(remoteDomain: uint32, remoteToken: bytes32): Asset
//
// @notice Get the enabled local token associated with the given remote domain and token.
// @param remoteDomain Remote domain
// @param remoteToken Remote token
// @return Local asset id
_getLocalToken:
	proto 2 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// src/roles/TokenController.algo.ts:254
	// _remoteTokensKey: bytes32 = this._hashRemoteDomainAndToken(
	// 			remoteDomain,
	// 			remoteToken
	// 		)
	frame_dig -2 // remoteToken: bytes32
	frame_dig -1 // remoteDomain: uint32
	callsub _hashRemoteDomainAndToken
	frame_bury 0 // _remoteTokensKey: bytes32

	// src/roles/TokenController.algo.ts:259
	// return this.remoteTokensToLocalTokens(_remoteTokensKey).value;
	frame_dig 0 // _remoteTokensKey: bytes32
	box_get
	assert
	btoi

	// set the subroutine return value
	frame_bury 0
	retsub

// _hashRemoteDomainAndToken(remoteDomain: uint32, remoteToken: bytes32): bytes32
//
// @notice hashes packed `_remoteDomain` and `_remoteToken`.
// @param remoteDomain Domain where message originated from
// @param remoteToken Address of remote token as bytes32
// @return keccak hash of packed remote domain and token
_hashRemoteDomainAndToken:
	proto 2 1

	// src/roles/TokenController.algo.ts:272
	// return keccak256(concat(rawBytes(remoteDomain), remoteToken)) as bytes32;
	frame_dig -1 // remoteDomain: uint32
	itob
	extract 4 4
	frame_dig -2 // remoteToken: bytes32
	concat
	keccak256
	retsub

// onlyOwner(): void
//
// @dev Throws if called by any account other than the owner.
onlyOwner:
	proto 0 0

	// src/roles/Ownable.algo.ts:52
	// assert(this.txn.sender === this._owner.value)
	txn Sender
	byte 0x5f6f776e6572 // "_owner"
	app_global_get
	==
	assert
	retsub

// owner()address
abi_route_owner:
	// The ABI return prefix
	byte 0x151f7c75

	// execute owner()address
	callsub owner
	concat
	log
	int 1
	return

// owner(): Address
//
// @dev Returns the address of the current owner.
owner:
	proto 0 1

	// src/roles/Ownable.algo.ts:62
	// return this._owner.value;
	byte 0x5f6f776e6572 // "_owner"
	app_global_get
	retsub

// _checkOwner()void
abi_route__checkOwner:
	// execute _checkOwner()void
	callsub _checkOwner
	int 1
	return

// _checkOwner(): void
//
// @dev Throws if the sender is not the owner.
_checkOwner:
	proto 0 0

	// src/roles/Ownable.algo.ts:70
	// assert(this.owner() == this.txn.sender)
	callsub owner
	txn Sender
	==
	assert
	retsub

// transferOwnership(address)void
abi_route_transferOwnership:
	// newOwner: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// execute transferOwnership(address)void
	callsub transferOwnership
	int 1
	return

// transferOwnership(newOwner: Address): void
//
// @dev Transfers ownership of the application to a new account (`newOwner`).
// Can only be called by the current owner.
transferOwnership:
	proto 1 0

	// src/roles/Ownable.algo.ts:80
	// this.onlyOwner()
	callsub onlyOwner

	// src/roles/Ownable.algo.ts:82
	// assert(newOwner != globals.zeroAddress)
	frame_dig -1 // newOwner: Address
	global ZeroAddress
	!=
	assert

	// src/roles/Ownable.algo.ts:84
	// this._transferOwnership(newOwner)
	frame_dig -1 // newOwner: Address
	callsub _transferOwnership
	retsub

// _transferOwnership(newOwner: Address): void
//
// @dev Transfers ownership of the application to a new account (`newOwner`).
// Internal function without access restriction.
_transferOwnership:
	proto 1 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// src/roles/Ownable.algo.ts:94
	// oldOwner: Address = this._owner.exists ? this._owner.value : globals.zeroAddress
	txna Applications 0
	byte 0x5f6f776e6572 // "_owner"
	app_global_get_ex
	swap
	pop
	bz ternary1_false
	byte 0x5f6f776e6572 // "_owner"
	app_global_get
	b ternary1_end

ternary1_false:
	global ZeroAddress

ternary1_end:
	frame_bury 0 // oldOwner: Address

	// src/roles/Ownable.algo.ts:95
	// this._owner.value = newOwner
	byte 0x5f6f776e6572 // "_owner"
	frame_dig -1 // newOwner: Address
	app_global_put

	// src/roles/Ownable.algo.ts:97
	// this.OwnershipTransferred.log({ oldAddress: oldOwner, newAddress: newOwner })
	byte 0x9a223efb // OwnershipTransferred(address,address)
	frame_dig 0 // oldOwner: Address
	frame_dig -1 // newOwner: Address
	concat
	concat
	log
	retsub

// pendingOwner()address
abi_route_pendingOwner:
	// The ABI return prefix
	byte 0x151f7c75

	// execute pendingOwner()address
	callsub pendingOwner
	concat
	log
	int 1
	return

// pendingOwner(): Address
//
// @dev Returns the address of the pending owner.
pendingOwner:
	proto 0 1

	// src/roles/Ownable2Step.algo.ts:51
	// return this._pendingOwner.value;
	byte 0x5f70656e64696e674f776e6572 // "_pendingOwner"
	app_global_get
	retsub

// transferOwnership2S(address)void
abi_route_transferOwnership2S:
	// newOwner: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// execute transferOwnership2S(address)void
	callsub transferOwnership2S
	int 1
	return

// transferOwnership2S(newOwner: Address): void
//
// @dev Starts the ownership transfer of the contract to a new account. Replaces the pending transfer if there is one.
// Can only be called by the current owner.
// FIX: Once overrides exist, rename to transferOwnership
transferOwnership2S:
	proto 1 0

	// src/roles/Ownable2Step.algo.ts:62
	// this.onlyOwner()
	callsub onlyOwner

	// src/roles/Ownable2Step.algo.ts:64
	// this._pendingOwner.value = newOwner
	byte 0x5f70656e64696e674f776e6572 // "_pendingOwner"
	frame_dig -1 // newOwner: Address
	app_global_put

	// src/roles/Ownable2Step.algo.ts:66
	// this.OwnershipTransferStarted.log({
	//             previousAddress: this._owner.value,
	//             newAddress: newOwner
	//         })
	byte 0x2424ff2a // OwnershipTransferStarted(address,address)
	byte 0x5f6f776e6572 // "_owner"
	app_global_get
	frame_dig -1 // newOwner: Address
	concat
	concat
	log
	retsub

// acceptOwnership()void
abi_route_acceptOwnership:
	// execute acceptOwnership()void
	callsub acceptOwnership
	int 1
	return

// acceptOwnership(): void
//
// @dev The new owner accepts the ownership transfer.
acceptOwnership:
	proto 0 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// src/roles/Ownable2Step.algo.ts:76
	// sender: Address = this.txn.sender
	txn Sender
	frame_bury 0 // sender: Address

	// src/roles/Ownable2Step.algo.ts:77
	// assert(this.pendingOwner() == sender)
	callsub pendingOwner
	frame_dig 0 // sender: Address
	==
	assert

	// src/roles/Ownable2Step.algo.ts:79
	// this._transferOwnership2S(sender)
	frame_dig 0 // sender: Address
	callsub _transferOwnership2S
	retsub

// _transferOwnership2S(newOwner: Address): void
//
// @dev Transfers ownership of the contract to a new account (`newOwner`) and deletes any pending owner.
// Internal function without access restriction.
// FIX: Once overrides exist, rename to _transferOwnership
_transferOwnership2S:
	proto 1 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// src/roles/Ownable2Step.algo.ts:90
	// oldOwner: Address = this._owner.exists ? this._owner.value : globals.zeroAddress
	txna Applications 0
	byte 0x5f6f776e6572 // "_owner"
	app_global_get_ex
	swap
	pop
	bz ternary3_false
	byte 0x5f6f776e6572 // "_owner"
	app_global_get
	b ternary3_end

ternary3_false:
	global ZeroAddress

ternary3_end:
	frame_bury 0 // oldOwner: Address

	// src/roles/Ownable2Step.algo.ts:91
	// this._owner.value = newOwner
	byte 0x5f6f776e6572 // "_owner"
	frame_dig -1 // newOwner: Address
	app_global_put

	// src/roles/Ownable2Step.algo.ts:93
	// this.OwnershipTransferred.log({ oldAddress: oldOwner, newAddress: newOwner })
	byte 0x9a223efb // OwnershipTransferred(address,address)
	frame_dig 0 // oldOwner: Address
	frame_dig -1 // newOwner: Address
	concat
	concat
	log
	retsub

// whenNotPaused(): void
//
// @dev Modifier to make a function callable only when the contract is not paused.
whenNotPaused:
	proto 0 0

	// src/roles/Pausable.algo.ts:48
	// assert(!this.paused.value)
	byte 0x706175736564 // "paused"
	app_global_get
	int 0
	getbit
	!
	assert
	retsub

// onlyPauser(): void
//
// @dev throws if called by any account other than the pauser
onlyPauser:
	proto 0 0

	// src/roles/Pausable.algo.ts:55
	// assert(this.txn.sender === this._pauser.value)
	txn Sender
	byte 0x5f706175736572 // "_pauser"
	app_global_get
	==
	assert
	retsub

// pauser()address
abi_route_pauser:
	// The ABI return prefix
	byte 0x151f7c75

	// execute pauser()address
	callsub pauser
	concat
	log
	int 1
	return

// pauser(): Address
//
// @notice Returns current pauser
// @return Pauser's address
pauser:
	proto 0 1

	// src/roles/Pausable.algo.ts:65
	// return this._pauser.value;
	byte 0x5f706175736572 // "_pauser"
	app_global_get
	retsub

// pause()void
abi_route_pause:
	// execute pause()void
	callsub pause
	int 1
	return

// pause(): void
//
// @dev called by the owner to pause, triggers stopped state
pause:
	proto 0 0

	// src/roles/Pausable.algo.ts:74
	// this.onlyPauser()
	callsub onlyPauser

	// src/roles/Pausable.algo.ts:76
	// this.paused.value = true
	byte 0x706175736564 // "paused"
	int 1
	byte 0x00
	int 0
	uncover 2
	setbit
	app_global_put

	// src/roles/Pausable.algo.ts:77
	// this.Pause.log({})
	byte 0xcf23a30f // Pause()
	concat
	log
	retsub

// unpause()void
abi_route_unpause:
	// execute unpause()void
	callsub unpause
	int 1
	return

// unpause(): void
//
// @dev called by the owner to unpause, returns to normal state
unpause:
	proto 0 0

	// src/roles/Pausable.algo.ts:84
	// this.onlyPauser()
	callsub onlyPauser

	// src/roles/Pausable.algo.ts:86
	// this.paused.value = false
	byte 0x706175736564 // "paused"
	int 0
	byte 0x00
	int 0
	uncover 2
	setbit
	app_global_put

	// src/roles/Pausable.algo.ts:87
	// this.Unpause.log({})
	byte 0xb163ee0b // Unpause()
	concat
	log
	retsub

// updatePauser(address)void
abi_route_updatePauser:
	// _newPauser: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// execute updatePauser(address)void
	callsub updatePauser
	int 1
	return

// updatePauser(_newPauser: Address): void
//
// @dev update the pauser role
updatePauser:
	proto 1 0

	// src/roles/Pausable.algo.ts:94
	// this.onlyPauser()
	callsub onlyPauser

	// src/roles/Pausable.algo.ts:96
	// assert(_newPauser != globals.zeroAddress)
	frame_dig -1 // _newPauser: Address
	global ZeroAddress
	!=
	assert

	// src/roles/Pausable.algo.ts:97
	// this._pauser.value = _newPauser
	byte 0x5f706175736572 // "_pauser"
	frame_dig -1 // _newPauser: Address
	app_global_put

	// src/roles/Pausable.algo.ts:98
	// this.PauserChanged.log({ newAddress: this._pauser.value })
	byte 0xcc40923c // PauserChanged(address)
	byte 0x5f706175736572 // "_pauser"
	app_global_get
	concat
	log
	retsub

// deploy(address)void
abi_route_deploy:
	// _tokenController: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// execute deploy(address)void
	callsub deploy
	int 1
	return

// deploy(_tokenController: Address): void
//
// @param _tokenController Token controller address
deploy:
	proto 1 0

	// src/TokenMinter.algo.ts:61
	// this._transferOwnership(this.txn.sender)
	txn Sender
	callsub _transferOwnership

	// src/TokenMinter.algo.ts:64
	// this._setTokenController(_tokenController)
	frame_dig -1 // _tokenController: Address
	callsub _setTokenController
	retsub

// onlyLocalTokenMessenger(): void
//
// @notice Only accept messages from the registered message transmitter on local domain
onlyLocalTokenMessenger:
	proto 0 0

	// src/TokenMinter.algo.ts:74
	// assert(this.txn.sender === this.localTokenMessenger.value.address)
	txn Sender
	byte 0x6c6f63616c546f6b656e4d657373656e676572 // "localTokenMessenger"
	app_global_get
	app_params_get AppAddress
	pop
	==
	assert
	retsub

// mint(uint32,byte[32],address,uint64)uint64
abi_route_mint:
	// The ABI return prefix
	byte 0x151f7c75

	// amount: uint64
	txna ApplicationArgs 4
	btoi

	// to: address
	txna ApplicationArgs 3
	dup
	len
	int 32
	==
	assert

	// burnToken: byte[32]
	txna ApplicationArgs 2
	dup
	len
	int 32
	==
	assert

	// sourceDomain: uint32
	txna ApplicationArgs 1
	dup
	len
	int 4
	==
	assert
	btoi

	// execute mint(uint32,byte[32],address,uint64)uint64
	callsub mint
	itob
	concat
	log
	int 1
	return

// mint(sourceDomain: uint32, burnToken: bytes32, to: Address, amount: uint64): Asset
//
// @notice Mints `amount` of local tokens corresponding to the
// given (`sourceDomain`, `burnToken`) pair, to `to` address.
// @dev reverts if the (`sourceDomain`, `burnToken`) pair does not
// map to a nonzero local token address. This mapping can be queried using
// getLocalToken().
// @param sourceDomain Source domain where `burnToken` was burned.
// @param burnToken Burned token address as bytes32.
// @param to Address to receive minted tokens, corresponding to `burnToken`,
// on this domain.
// @param amount Amount of tokens to mint. Must be less than or equal
// to the minterAllowance of this TokenMinter for given `_mintToken`.
// @return mintToken token minted.
mint:
	proto 4 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// src/TokenMinter.algo.ts:102
	// this.whenNotPaused()
	callsub whenNotPaused

	// src/TokenMinter.algo.ts:103
	// this.onlyLocalTokenMessenger()
	callsub onlyLocalTokenMessenger

	// src/TokenMinter.algo.ts:105
	// _mintToken: Asset = this._getLocalToken(sourceDomain, burnToken)
	frame_dig -2 // burnToken: bytes32
	frame_dig -1 // sourceDomain: uint32
	callsub _getLocalToken
	frame_bury 0 // _mintToken: Asset

	// src/TokenMinter.algo.ts:106
	// assert(_mintToken)
	frame_dig 0 // _mintToken: Asset
	assert

	// src/TokenMinter.algo.ts:109
	// sendAssetTransfer({
	// 			xferAsset: _mintToken,
	// 			assetReceiver: to,
	// 			assetAmount: amount
	// 		})
	itxn_begin
	int axfer
	itxn_field TypeEnum

	// src/TokenMinter.algo.ts:110
	// xferAsset: _mintToken
	frame_dig 0 // _mintToken: Asset
	itxn_field XferAsset

	// src/TokenMinter.algo.ts:111
	// assetReceiver: to
	frame_dig -3 // to: Address
	itxn_field AssetReceiver

	// src/TokenMinter.algo.ts:112
	// assetAmount: amount
	frame_dig -4 // amount: uint64
	itxn_field AssetAmount

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// src/TokenMinter.algo.ts:115
	// return _mintToken;
	frame_dig 0 // _mintToken: Asset

	// set the subroutine return value
	frame_bury 0
	retsub

// burn(asset,uint64)void
abi_route_burn:
	// burnAmount: uint64
	txna ApplicationArgs 2
	btoi

	// burnToken: asset
	txna ApplicationArgs 1
	btoi
	txnas Assets

	// execute burn(asset,uint64)void
	callsub burn
	int 1
	return

// burn(burnToken: Asset, burnAmount: uint64): void
//
// @notice Burn tokens owned by this TokenMinter.
// @param burnToken burnable token id.
// @param burnAmount amount of tokens to burn. Must be
// > 0, and <= maximum burn amount per message.
burn:
	proto 2 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// src/TokenMinter.algo.ts:128
	// this.whenNotPaused()
	callsub whenNotPaused

	// src/TokenMinter.algo.ts:129
	// this.onlyLocalTokenMessenger()
	callsub onlyLocalTokenMessenger

	// src/TokenMinter.algo.ts:130
	// this.onlyWithinBurnLimit(burnToken, burnAmount)
	frame_dig -2 // burnAmount: uint64
	frame_dig -1 // burnToken: Asset
	callsub onlyWithinBurnLimit

	// src/TokenMinter.algo.ts:132
	// reserveAddress: Address = burnToken.reserve
	frame_dig -1 // burnToken: Asset
	asset_params_get AssetReserve
	pop
	frame_bury 0 // reserveAddress: Address

	// src/TokenMinter.algo.ts:135
	// sendAssetTransfer({
	// 			xferAsset: burnToken,
	// 			assetReceiver: reserveAddress,
	// 			assetAmount: burnAmount
	// 		})
	itxn_begin
	int axfer
	itxn_field TypeEnum

	// src/TokenMinter.algo.ts:136
	// xferAsset: burnToken
	frame_dig -1 // burnToken: Asset
	itxn_field XferAsset

	// src/TokenMinter.algo.ts:137
	// assetReceiver: reserveAddress
	frame_dig 0 // reserveAddress: Address
	itxn_field AssetReceiver

	// src/TokenMinter.algo.ts:138
	// assetAmount: burnAmount
	frame_dig -2 // burnAmount: uint64
	itxn_field AssetAmount

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	retsub

// addLocalTokenMessenger(application)void
abi_route_addLocalTokenMessenger:
	// newLocalTokenMessenger: application
	txna ApplicationArgs 1
	btoi
	txnas Applications

	// execute addLocalTokenMessenger(application)void
	callsub addLocalTokenMessenger
	int 1
	return

// addLocalTokenMessenger(newLocalTokenMessenger: Application): void
//
// @notice Add TokenMessenger for the local domain. Only this TokenMessenger
// has permission to call mint() and burn() on this TokenMinter.
// @dev Reverts if a TokenMessenger is already set for the local domain.
// @param newLocalTokenMessenger The address of the new TokenMessenger on the local domain.
addLocalTokenMessenger:
	proto 1 0

	// src/TokenMinter.algo.ts:151
	// this.onlyOwner()
	callsub onlyOwner

	// src/TokenMinter.algo.ts:153
	// assert(newLocalTokenMessenger)
	frame_dig -1 // newLocalTokenMessenger: Application
	assert

	// src/TokenMinter.algo.ts:154
	// assert(!this.localTokenMessenger.exists)
	txna Applications 0
	byte 0x6c6f63616c546f6b656e4d657373656e676572 // "localTokenMessenger"
	app_global_get_ex
	swap
	pop
	!
	assert

	// src/TokenMinter.algo.ts:156
	// this.localTokenMessenger.value = newLocalTokenMessenger
	byte 0x6c6f63616c546f6b656e4d657373656e676572 // "localTokenMessenger"
	frame_dig -1 // newLocalTokenMessenger: Application
	app_global_put

	// src/TokenMinter.algo.ts:158
	// this.LocalTokenMessengerAdded.log({
	// 			localTokenMessenger: newLocalTokenMessenger
	// 		})
	byte 0x5ca790b1 // LocalTokenMessengerAdded(uint64)
	frame_dig -1 // newLocalTokenMessenger: Application
	itob
	concat
	log
	retsub

// removeLocalTokenMessenger()void
abi_route_removeLocalTokenMessenger:
	// execute removeLocalTokenMessenger()void
	callsub removeLocalTokenMessenger
	int 1
	return

// removeLocalTokenMessenger(): void
//
// @notice Remove the TokenMessenger for the local domain.
// @dev Reverts if the TokenMessenger of the local domain is not set.
removeLocalTokenMessenger:
	proto 0 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// src/TokenMinter.algo.ts:168
	// this.onlyOwner()
	callsub onlyOwner

	// src/TokenMinter.algo.ts:170
	// assert(this.localTokenMessenger.exists)
	txna Applications 0
	byte 0x6c6f63616c546f6b656e4d657373656e676572 // "localTokenMessenger"
	app_global_get_ex
	swap
	pop
	assert

	// src/TokenMinter.algo.ts:172
	// _localTokenMessengerBeforeRemoval: Application = this.localTokenMessenger.value
	byte 0x6c6f63616c546f6b656e4d657373656e676572 // "localTokenMessenger"
	app_global_get
	frame_bury 0 // _localTokenMessengerBeforeRemoval: Application

	// src/TokenMinter.algo.ts:174
	// this.localTokenMessenger.delete()
	byte 0x6c6f63616c546f6b656e4d657373656e676572 // "localTokenMessenger"
	app_global_del

	// src/TokenMinter.algo.ts:176
	// this.LocalTokenMessengerRemoved.log({
	// 			localTokenMessenger: _localTokenMessengerBeforeRemoval
	// 		})
	byte 0xc49b7820 // LocalTokenMessengerRemoved(uint64)
	frame_dig 0 // _localTokenMessengerBeforeRemoval: Application
	itob
	concat
	log
	retsub

// setTokenController(address)void
abi_route_setTokenController:
	// newTokenController: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// execute setTokenController(address)void
	callsub setTokenController
	int 1
	return

// setTokenController(newTokenController: Address): void
//
// @notice Set tokenController to `newTokenController`, and
// emit `SetTokenController` event.
// @dev newTokenController must be nonzero.
// @param newTokenController address of new token controller
setTokenController:
	proto 1 0

	// src/TokenMinter.algo.ts:190
	// this.onlyOwner()
	callsub onlyOwner

	// src/TokenMinter.algo.ts:192
	// this._setTokenController(newTokenController)
	frame_dig -1 // newTokenController: Address
	callsub _setTokenController
	retsub

// getLocalToken(uint32,byte[32])uint64
abi_route_getLocalToken:
	// The ABI return prefix
	byte 0x151f7c75

	// remoteToken: byte[32]
	txna ApplicationArgs 2
	dup
	len
	int 32
	==
	assert

	// remoteDomain: uint32
	txna ApplicationArgs 1
	dup
	len
	int 4
	==
	assert
	btoi

	// execute getLocalToken(uint32,byte[32])uint64
	callsub getLocalToken
	itob
	concat
	log
	int 1
	return

// getLocalToken(remoteDomain: uint32, remoteToken: bytes32): Asset
//
// @notice Get the local token id associated with the given
// remote domain and token.
// @param remoteDomain Remote domain
// @param remoteToken Remote token
// @return local token id
getLocalToken:
	proto 2 1

	// src/TokenMinter.algo.ts:206
	// return this._getLocalToken(remoteDomain, remoteToken);
	frame_dig -2 // remoteToken: bytes32
	frame_dig -1 // remoteDomain: uint32
	callsub _getLocalToken
	retsub

create_NoOp:
	method "deploy(address)void"
	txna ApplicationArgs 0
	match abi_route_deploy
	err

call_NoOp:
	method "tokenController()address"
	method "linkTokenPair(asset,uint32,byte[32])void"
	method "unlinkTokenPair(asset,uint32,byte[32])void"
	method "setMaxBurnAmountPerMessage(asset,uint64)void"
	method "owner()address"
	method "_checkOwner()void"
	method "transferOwnership(address)void"
	method "pendingOwner()address"
	method "transferOwnership2S(address)void"
	method "acceptOwnership()void"
	method "pauser()address"
	method "pause()void"
	method "unpause()void"
	method "updatePauser(address)void"
	method "mint(uint32,byte[32],address,uint64)uint64"
	method "burn(asset,uint64)void"
	method "addLocalTokenMessenger(application)void"
	method "removeLocalTokenMessenger()void"
	method "setTokenController(address)void"
	method "getLocalToken(uint32,byte[32])uint64"
	txna ApplicationArgs 0
	match abi_route_tokenController abi_route_linkTokenPair abi_route_unlinkTokenPair abi_route_setMaxBurnAmountPerMessage abi_route_owner abi_route__checkOwner abi_route_transferOwnership abi_route_pendingOwner abi_route_transferOwnership2S abi_route_acceptOwnership abi_route_pauser abi_route_pause abi_route_unpause abi_route_updatePauser abi_route_mint abi_route_burn abi_route_addLocalTokenMessenger abi_route_removeLocalTokenMessenger abi_route_setTokenController abi_route_getLocalToken
	err