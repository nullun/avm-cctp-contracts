#pragma version 10

// This TEAL was generated by TEALScript v0.78.1
// https://github.com/algorandfoundation/TEALScript

// This contract is compliant with and/or implements the following ARCs: [ ARC4 ]

// The following ten lines of TEAL handle initial program flow
// This pattern is used to make it easy for anyone to parse the start of the program and determine if a specific action is allowed
// Here, action refers to the OnComplete in combination with whether the app is being created or called
// Every possible action for this contract is represented in the switch statement
// If the action is not implmented in the contract, its respective branch will be "NOT_IMPLEMENTED" which just contains "err"
txn ApplicationID
!
int 6
*
txn OnCompletion
+
switch call_NoOp NOT_IMPLEMENTED NOT_IMPLEMENTED NOT_IMPLEMENTED NOT_IMPLEMENTED NOT_IMPLEMENTED create_NoOp NOT_IMPLEMENTED NOT_IMPLEMENTED NOT_IMPLEMENTED NOT_IMPLEMENTED NOT_IMPLEMENTED

NOT_IMPLEMENTED:
	err

// onlyOwner(): void
//
// @dev Throws if called by any account other than the owner.
onlyOwner:
	proto 0 0

	// src/roles/Ownable.algo.ts:52
	// assert(this.txn.sender === this._owner.value)
	txn Sender
	byte 0x5f6f776e6572 // "_owner"
	app_global_get
	==
	assert
	retsub

// owner()address
abi_route_owner:
	// The ABI return prefix
	byte 0x151f7c75

	// execute owner()address
	callsub owner
	concat
	log
	int 1
	return

// owner(): Address
//
// @dev Returns the address of the current owner.
owner:
	proto 0 1

	// src/roles/Ownable.algo.ts:62
	// return this._owner.value;
	byte 0x5f6f776e6572 // "_owner"
	app_global_get
	retsub

// _checkOwner()void
abi_route__checkOwner:
	// execute _checkOwner()void
	callsub _checkOwner
	int 1
	return

// _checkOwner(): void
//
// @dev Throws if the sender is not the owner.
_checkOwner:
	proto 0 0

	// src/roles/Ownable.algo.ts:70
	// assert(this.owner() == this.txn.sender)
	callsub owner
	txn Sender
	==
	assert
	retsub

// transferOwnership(address)void
abi_route_transferOwnership:
	// newOwner: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// execute transferOwnership(address)void
	callsub transferOwnership
	int 1
	return

// transferOwnership(newOwner: Address): void
//
// @dev Transfers ownership of the application to a new account (`newOwner`).
// Can only be called by the current owner.
transferOwnership:
	proto 1 0

	// src/roles/Ownable.algo.ts:80
	// this.onlyOwner()
	callsub onlyOwner

	// src/roles/Ownable.algo.ts:82
	// assert(newOwner != globals.zeroAddress)
	frame_dig -1 // newOwner: Address
	global ZeroAddress
	!=
	assert

	// src/roles/Ownable.algo.ts:84
	// this._transferOwnership(newOwner)
	frame_dig -1 // newOwner: Address
	callsub _transferOwnership
	retsub

// _transferOwnership(newOwner: Address): void
//
// @dev Transfers ownership of the application to a new account (`newOwner`).
// Internal function without access restriction.
_transferOwnership:
	proto 1 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// src/roles/Ownable.algo.ts:94
	// oldOwner: Address = this._owner.exists ? this._owner.value : globals.zeroAddress
	txna Applications 0
	byte 0x5f6f776e6572 // "_owner"
	app_global_get_ex
	swap
	pop
	bz ternary1_false
	byte 0x5f6f776e6572 // "_owner"
	app_global_get
	b ternary1_end

ternary1_false:
	global ZeroAddress

ternary1_end:
	frame_bury 0 // oldOwner: Address

	// src/roles/Ownable.algo.ts:95
	// this._owner.value = newOwner
	byte 0x5f6f776e6572 // "_owner"
	frame_dig -1 // newOwner: Address
	app_global_put

	// src/roles/Ownable.algo.ts:97
	// this.OwnershipTransferred.log({ oldAddress: oldOwner, newAddress: newOwner })
	byte 0x9a223efb // OwnershipTransferred(address,address)
	frame_dig 0 // oldOwner: Address
	frame_dig -1 // newOwner: Address
	concat
	concat
	log
	retsub

// pendingOwner()address
abi_route_pendingOwner:
	// The ABI return prefix
	byte 0x151f7c75

	// execute pendingOwner()address
	callsub pendingOwner
	concat
	log
	int 1
	return

// pendingOwner(): Address
//
// @dev Returns the address of the pending owner.
pendingOwner:
	proto 0 1

	// src/roles/Ownable2Step.algo.ts:51
	// return this._pendingOwner.value;
	byte 0x5f70656e64696e674f776e6572 // "_pendingOwner"
	app_global_get
	retsub

// transferOwnership2S(address)void
abi_route_transferOwnership2S:
	// newOwner: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// execute transferOwnership2S(address)void
	callsub transferOwnership2S
	int 1
	return

// transferOwnership2S(newOwner: Address): void
//
// @dev Starts the ownership transfer of the contract to a new account. Replaces the pending transfer if there is one.
// Can only be called by the current owner.
// FIX: Once overrides exist, rename to transferOwnership
transferOwnership2S:
	proto 1 0

	// src/roles/Ownable2Step.algo.ts:62
	// this.onlyOwner()
	callsub onlyOwner

	// src/roles/Ownable2Step.algo.ts:64
	// this._pendingOwner.value = newOwner
	byte 0x5f70656e64696e674f776e6572 // "_pendingOwner"
	frame_dig -1 // newOwner: Address
	app_global_put

	// src/roles/Ownable2Step.algo.ts:66
	// this.OwnershipTransferStarted.log({
	//             previousAddress: this._owner.value,
	//             newAddress: newOwner
	//         })
	byte 0x2424ff2a // OwnershipTransferStarted(address,address)
	byte 0x5f6f776e6572 // "_owner"
	app_global_get
	frame_dig -1 // newOwner: Address
	concat
	concat
	log
	retsub

// acceptOwnership()void
abi_route_acceptOwnership:
	// execute acceptOwnership()void
	callsub acceptOwnership
	int 1
	return

// acceptOwnership(): void
//
// @dev The new owner accepts the ownership transfer.
acceptOwnership:
	proto 0 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// src/roles/Ownable2Step.algo.ts:76
	// sender: Address = this.txn.sender
	txn Sender
	frame_bury 0 // sender: Address

	// src/roles/Ownable2Step.algo.ts:77
	// assert(this.pendingOwner() == sender)
	callsub pendingOwner
	frame_dig 0 // sender: Address
	==
	assert

	// src/roles/Ownable2Step.algo.ts:79
	// this._transferOwnership2S(sender)
	frame_dig 0 // sender: Address
	callsub _transferOwnership2S
	retsub

// _transferOwnership2S(newOwner: Address): void
//
// @dev Transfers ownership of the contract to a new account (`newOwner`) and deletes any pending owner.
// Internal function without access restriction.
// FIX: Once overrides exist, rename to _transferOwnership
_transferOwnership2S:
	proto 1 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// src/roles/Ownable2Step.algo.ts:90
	// oldOwner: Address = this._owner.exists ? this._owner.value : globals.zeroAddress
	txna Applications 0
	byte 0x5f6f776e6572 // "_owner"
	app_global_get_ex
	swap
	pop
	bz ternary3_false
	byte 0x5f6f776e6572 // "_owner"
	app_global_get
	b ternary3_end

ternary3_false:
	global ZeroAddress

ternary3_end:
	frame_bury 0 // oldOwner: Address

	// src/roles/Ownable2Step.algo.ts:91
	// this._owner.value = newOwner
	byte 0x5f6f776e6572 // "_owner"
	frame_dig -1 // newOwner: Address
	app_global_put

	// src/roles/Ownable2Step.algo.ts:93
	// this.OwnershipTransferred.log({ oldAddress: oldOwner, newAddress: newOwner })
	byte 0x9a223efb // OwnershipTransferred(address,address)
	frame_dig 0 // oldOwner: Address
	frame_dig -1 // newOwner: Address
	concat
	concat
	log
	retsub

// onlyRemoteTokenMessenger(domain: uint<32>, tokenMessenger: bytes32): void
//
// @notice Only accept messages from a registered TokenMessenger contract on given remote domain
// @param domain The remote domain
// @param tokenMessenger The address of the TokenMessenger contract for the given remote domain
onlyRemoteTokenMessenger:
	proto 2 0

	// src/TokenMessenger.algo.ts:137
	// assert(this.remoteTokenMessengers(domain).value === tokenMessenger)
	frame_dig -1 // domain: uint<32>
	itob
	extract 4 4
	box_get
	assert
	frame_dig -2 // tokenMessenger: bytes32
	==
	assert
	retsub

// onlyLocalMessageTransmitter(): void
//
// @notice Only accept messages from the registered message transmitter on local domain
onlyLocalMessageTransmitter:
	proto 0 0

	// src/TokenMessenger.algo.ts:144
	// assert(this.txn.sender === this.localMessageTransmitter.value.address)
	txn Sender
	byte 0x6c6f63616c4d6573736167655472616e736d6974746572 // "localMessageTransmitter"
	app_global_get
	app_params_get AppAddress
	pop
	==
	assert
	retsub

// _getLocalMinter(): Application
//
// @notice return the local minter address if it is set, else revert.
// @return local minter as ITokenMinter.
_getLocalMinter:
	proto 0 1

	// src/TokenMessenger.algo.ts:154
	// assert(this.localMinter.value)
	byte 0x6c6f63616c4d696e746572 // "localMinter"
	app_global_get
	assert

	// src/TokenMessenger.algo.ts:156
	// return this.localMinter.value;
	byte 0x6c6f63616c4d696e746572 // "localMinter"
	app_global_get
	retsub

// _sendDepositForBurnMessage(_destinationDomain: uint<32>, _destinationTokenMessenger: bytes32, _destinationCaller: bytes32, _burnMessage: bytes): uint<64>
//
// @notice Sends a BurnMessage through the local message transmitter
// @dev calls local message transmitter's sendMessage() function if `_destinationCaller` == bytes32(0),
// or else calls sendMessageWithCaller().
// @param _destinationDomain destination domain
// @param _destinationTokenMessenger address of registered TokenMessenger contract on destination domain, as bytes32
// @param _destinationCaller caller on the destination domain, as bytes32. If `_destinationCaller` == bytes32(0),
// any address can call receiveMessage() on destination domain.
// @param _burnMessage formatted BurnMessage bytes (message body)
// @return nonce unique nonce reserved by message
_sendDepositForBurnMessage:
	proto 4 1

	// if0_condition
	// src/TokenMessenger.algo.ts:176
	// _destinationCaller === bzero(32) as bytes32
	frame_dig -3 // _destinationCaller: bytes32
	byte 0x0000000000000000000000000000000000000000000000000000000000000000
	==
	bz if0_else

	// if0_consequent
	// src/TokenMessenger.algo.ts:177
	// return sendMethodCall<[uint<32>, bytes32, bytes], uint<64>>({
	// 				applicationID: this.localMessageTransmitter.value,
	// 				name: 'sendMessage',
	// 				methodArgs: [
	// 					_destinationDomain,
	// 					_destinationTokenMessenger,
	// 					_burnMessage
	// 				]
	// 			});
	itxn_begin
	int appl
	itxn_field TypeEnum
	method "sendMessage(uint32,byte[32],byte[])uint64"
	itxn_field ApplicationArgs

	// src/TokenMessenger.algo.ts:178
	// applicationID: this.localMessageTransmitter.value
	byte 0x6c6f63616c4d6573736167655472616e736d6974746572 // "localMessageTransmitter"
	app_global_get
	itxn_field ApplicationID

	// src/TokenMessenger.algo.ts:180
	// methodArgs: [
	// 					_destinationDomain,
	// 					_destinationTokenMessenger,
	// 					_burnMessage
	// 				]
	frame_dig -1 // _destinationDomain: uint<32>
	itob
	extract 4 4
	itxn_field ApplicationArgs
	frame_dig -2 // _destinationTokenMessenger: bytes32
	itxn_field ApplicationArgs
	frame_dig -4 // _burnMessage: bytes
	dup
	len
	itob
	extract 6 2
	swap
	concat
	itxn_field ApplicationArgs

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	itxn NumLogs
	int 1
	-
	itxnas Logs
	extract 4 0
	btoi
	retsub
	b if0_end

if0_else:
	// src/TokenMessenger.algo.ts:187
	// return sendMethodCall<[uint<32>, bytes32, bytes32, bytes], uint<64>>({
	// 				applicationID: this.localMessageTransmitter.value,
	// 				name: 'sendMessageWithCaller',
	// 				methodArgs: [
	// 					_destinationDomain,
	// 					_destinationTokenMessenger,
	// 					_destinationCaller,
	// 					_burnMessage
	// 				],
	// 			});
	itxn_begin
	int appl
	itxn_field TypeEnum
	method "sendMessageWithCaller(uint32,byte[32],byte[32],byte[])uint64"
	itxn_field ApplicationArgs

	// src/TokenMessenger.algo.ts:188
	// applicationID: this.localMessageTransmitter.value
	byte 0x6c6f63616c4d6573736167655472616e736d6974746572 // "localMessageTransmitter"
	app_global_get
	itxn_field ApplicationID

	// src/TokenMessenger.algo.ts:190
	// methodArgs: [
	// 					_destinationDomain,
	// 					_destinationTokenMessenger,
	// 					_destinationCaller,
	// 					_burnMessage
	// 				]
	frame_dig -1 // _destinationDomain: uint<32>
	itob
	extract 4 4
	itxn_field ApplicationArgs
	frame_dig -2 // _destinationTokenMessenger: bytes32
	itxn_field ApplicationArgs
	frame_dig -3 // _destinationCaller: bytes32
	itxn_field ApplicationArgs
	frame_dig -4 // _burnMessage: bytes
	dup
	len
	itob
	extract 6 2
	swap
	concat
	itxn_field ApplicationArgs

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	itxn NumLogs
	int 1
	-
	itxnas Logs
	extract 4 0
	btoi
	retsub

if0_end:
	retsub

// _getRemoteTokenMessenger(_domain: uint<32>): bytes32
//
// @notice return the remote TokenMessenger for the given `_domain` if one exists, else revert.
// @param _domain The domain for which to get the remote TokenMessenger
// @return _tokenMessenger The address of the TokenMessenger on `_domain` as bytes32
_getRemoteTokenMessenger:
	proto 1 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// src/TokenMessenger.algo.ts:208
	// _tokenMessenger = this.remoteTokenMessengers(_domain).value
	frame_dig -1 // _domain: uint<32>
	itob
	extract 4 4
	frame_bury 0 // storage key//_tokenMessenger

	// src/TokenMessenger.algo.ts:210
	// assert(_tokenMessenger !== bzero(32) as bytes32)
	frame_dig 0 // storage key//_tokenMessenger
	box_get
	assert
	byte 0x0000000000000000000000000000000000000000000000000000000000000000
	!=
	assert

	// src/TokenMessenger.algo.ts:212
	// return _tokenMessenger;
	frame_dig 0 // storage key//_tokenMessenger
	box_get
	assert

	// set the subroutine return value
	frame_bury 0
	retsub

// _depositForBurn(_axfer: AssetTransferTxn, _destinationDomain: uint<32>, _mintRecipient: bytes32, _burnToken: Asset, _destinationCaller: bytes32): uint<64>
//
// @notice Deposits and burns tokens from sender to be minted on destination domain.
// Emits a `DepositForBurn` event.
// @param _axfer asset transfer of tokens to burn (must be non-zero)
// @param _destinationDomain destination domain
// @param _mintRecipient address of mint recipient on destination domain
// @param _burnToken address of contract to burn deposited tokens, on local domain
// @param _destinationCaller caller on the destination domain, as bytes32
// @return nonce unique nonce reserved by message
_depositForBurn:
	proto 5 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 4

	// src/TokenMessenger.algo.ts:232
	// assert(_axfer.assetAmount)
	frame_dig -1 // _axfer: AssetTransferTxn
	gtxns AssetAmount
	assert

	// src/TokenMessenger.algo.ts:233
	// assert(_mintRecipient != bzero(32) as bytes32)
	frame_dig -3 // _mintRecipient: bytes32
	byte 0x0000000000000000000000000000000000000000000000000000000000000000
	!=
	assert

	// src/TokenMessenger.algo.ts:235
	// _destinationTokenMessenger: bytes32 = this._getRemoteTokenMessenger(
	// 			_destinationDomain
	// 		)
	frame_dig -2 // _destinationDomain: uint<32>
	callsub _getRemoteTokenMessenger
	frame_bury 0 // _destinationTokenMessenger: bytes32

	// src/TokenMessenger.algo.ts:239
	// _localMinter: Application = this._getLocalMinter()
	callsub _getLocalMinter
	frame_bury 1 // _localMinter: Application

	// src/TokenMessenger.algo.ts:242
	// assert(_axfer.xferAsset === _burnToken)
	frame_dig -1 // _axfer: AssetTransferTxn
	gtxns XferAsset
	frame_dig -4 // _burnToken: Asset
	==
	assert

	// src/TokenMessenger.algo.ts:243
	// assert(_axfer.assetCloseTo !== _localMinter.address)
	frame_dig -1 // _axfer: AssetTransferTxn
	gtxns AssetCloseTo
	frame_dig 1 // _localMinter: Application
	app_params_get AppAddress
	pop
	!=
	assert

	// src/TokenMessenger.algo.ts:244
	// assert(_axfer.assetReceiver === _localMinter.address)
	frame_dig -1 // _axfer: AssetTransferTxn
	gtxns AssetReceiver
	frame_dig 1 // _localMinter: Application
	app_params_get AppAddress
	pop
	==
	assert

	// src/TokenMessenger.algo.ts:247
	// sendMethodCall<[Asset, uint<64>], void>({
	// 			applicationID: _localMinter,
	// 			name: 'burn',
	// 			methodArgs: [
	// 				_burnToken,
	// 				_axfer.assetAmount
	// 			],
	// 		})
	itxn_begin
	int appl
	itxn_field TypeEnum
	method "burn(asset,uint64)void"
	itxn_field ApplicationArgs

	// src/TokenMessenger.algo.ts:248
	// applicationID: _localMinter
	frame_dig 1 // _localMinter: Application
	itxn_field ApplicationID

	// src/TokenMessenger.algo.ts:250
	// methodArgs: [
	// 				_burnToken,
	// 				_axfer.assetAmount
	// 			]
	frame_dig -4 // _burnToken: Asset
	itxn_field Assets
	byte 0x0000000000000000
	itxn_field ApplicationArgs
	frame_dig -1 // _axfer: AssetTransferTxn
	gtxns AssetAmount
	itob
	itxn_field ApplicationArgs

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// src/TokenMessenger.algo.ts:257
	// _burnMessage: BurnMessage = {
	// 			_version: this.messageBodyVersion.value as uint<32>,
	// 			_burnToken: concat(bzero(32 - len(itob(_burnToken))), itob(_burnToken)) as bytes32,
	// 			_mintRecipient: _mintRecipient,
	// 			_amount: _axfer.assetAmount as uint<256>,
	// 			_messageSender: rawBytes(this.txn.sender) as bytes32
	// 		}
	byte 0x6d657373616765426f647956657273696f6e // "messageBodyVersion"
	app_global_get
	btoi
	itob
	extract 4 4
	int 32
	frame_dig -4 // _burnToken: Asset
	itob
	len
	-
	bzero
	frame_dig -4 // _burnToken: Asset
	itob
	concat
	byte 0x0000000000000000000000000000000000000000000000000000000000000000
	concat
	dup
	extract 32 0
	byte 0x
	b==
	assert
	extract 0 32
	concat
	frame_dig -3 // _mintRecipient: bytes32
	concat
	frame_dig -1 // _axfer: AssetTransferTxn
	gtxns AssetAmount
	itob
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	concat
	txn Sender
	byte 0x0000000000000000000000000000000000000000000000000000000000000000
	concat
	dup
	extract 32 0
	byte 0x
	b==
	assert
	extract 0 32
	concat
	frame_bury 2 // _burnMessage: BurnMessage

	// src/TokenMessenger.algo.ts:265
	// _nonceReserved: uint<64> = this._sendDepositForBurnMessage(
	// 			_destinationDomain,
	// 			_destinationTokenMessenger,
	// 			_destinationCaller,
	// 			rawBytes(_burnMessage)
	// 		)
	frame_dig 2 // _burnMessage: BurnMessage
	frame_dig -5 // _destinationCaller: bytes32
	frame_dig 0 // _destinationTokenMessenger: bytes32
	frame_dig -2 // _destinationDomain: uint<32>
	callsub _sendDepositForBurnMessage
	frame_bury 3 // _nonceReserved: uint<64>

	// src/TokenMessenger.algo.ts:272
	// this.DepositForBurn.log({
	// 			nonce: _nonceReserved,
	// 			burnToken: _burnToken,
	// 			amount: _axfer.assetAmount as uint<256>,
	// 			depositor: this.txn.sender,
	// 			mintRecipient: _mintRecipient,
	// 			destinationDomain: _destinationDomain,
	// 			destinationTokenMessenger: _destinationTokenMessenger,
	// 			destinationCaller: _destinationCaller
	// 		})
	byte 0xd9074ca1 // DepositForBurn(uint64,uint64,uint256,address,byte[32],uint32,byte[32],byte[32])
	frame_dig 3 // _nonceReserved: uint<64>
	itob
	frame_dig -4 // _burnToken: Asset
	itob
	concat
	frame_dig -1 // _axfer: AssetTransferTxn
	gtxns AssetAmount
	itob
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	concat
	txn Sender
	concat
	frame_dig -3 // _mintRecipient: bytes32
	concat
	frame_dig -2 // _destinationDomain: uint<32>
	itob
	extract 4 4
	concat
	frame_dig 0 // _destinationTokenMessenger: bytes32
	concat
	frame_dig -5 // _destinationCaller: bytes32
	concat
	concat
	log

	// src/TokenMessenger.algo.ts:283
	// return _nonceReserved;
	frame_dig 3 // _nonceReserved: uint<64>

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 3
	retsub

// _mintAndWithdraw(_tokenMinter: Application, _remoteDomain: uint<32>, _burnToken: bytes32, _mintRecipient: Address, _amount: uint<64>): void
//
// @notice Mints tokens to a recipient
// @param _tokenMinter id of TokenMinter contract
// @param _remoteDomain domain where burned tokens originate from
// @param _burnToken address of token burned
// @param _mintRecipient recipient address of minted tokens
// @param _amount amount of minted tokens
_mintAndWithdraw:
	proto 5 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// src/TokenMessenger.algo.ts:301
	// _mintToken = sendMethodCall<[uint<32>, bytes32, Address, uint<64>], Asset>({
	// 			applicationID: _tokenMinter,
	// 			name: 'mint',
	// 			methodArgs: [
	// 				_remoteDomain,
	// 				_burnToken,
	// 				_mintRecipient,
	// 				_amount
	// 			]
	// 		})
	itxn_begin
	int appl
	itxn_field TypeEnum
	method "mint(uint32,byte[32],address,uint64)uint64"
	itxn_field ApplicationArgs

	// src/TokenMessenger.algo.ts:302
	// applicationID: _tokenMinter
	frame_dig -1 // _tokenMinter: Application
	itxn_field ApplicationID

	// src/TokenMessenger.algo.ts:304
	// methodArgs: [
	// 				_remoteDomain,
	// 				_burnToken,
	// 				_mintRecipient,
	// 				_amount
	// 			]
	frame_dig -2 // _remoteDomain: uint<32>
	itob
	extract 4 4
	itxn_field ApplicationArgs
	frame_dig -3 // _burnToken: bytes32
	itxn_field ApplicationArgs
	frame_dig -4 // _mintRecipient: Address
	itxn_field ApplicationArgs
	frame_dig -5 // _amount: uint<64>
	itob
	itxn_field ApplicationArgs

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	itxn NumLogs
	int 1
	-
	itxnas Logs
	extract 4 0
	btoi
	frame_bury 0 // _mintToken: asset

	// src/TokenMessenger.algo.ts:312
	// this.MintAndWithdraw.log({
	// 			mintRecipient: _mintRecipient,
	// 			amount: <uint<256>>_amount,
	// 			mintToken: _mintToken
	// 		})
	byte 0xda535dba // MintAndWithdraw(address,uint256,uint64)
	frame_dig -4 // _mintRecipient: Address
	frame_dig -5 // _amount: uint<64>
	itob
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	concat
	frame_dig 0 // _mintToken: asset
	itob
	concat
	concat
	log
	retsub

// depositForBurn(axfer,uint32,byte[32],asset)uint64
abi_route_depositForBurn:
	// The ABI return prefix
	byte 0x151f7c75

	// burnToken: asset
	txna ApplicationArgs 3
	btoi
	txnas Assets

	// mintRecipient: byte[32]
	txna ApplicationArgs 2
	dup
	len
	int 32
	==
	assert

	// destinationDomain: uint32
	txna ApplicationArgs 1
	dup
	len
	int 4
	==
	assert
	btoi

	// axfer: axfer
	txn GroupIndex
	int 1
	-
	dup
	gtxns TypeEnum
	int axfer
	==
	assert

	// execute depositForBurn(axfer,uint32,byte[32],asset)uint64
	callsub depositForBurn
	itob
	concat
	log
	int 1
	return

// depositForBurn(axfer: AssetTransferTxn, destinationDomain: uint<32>, mintRecipient: bytes32, burnToken: Asset): uint<64>
//
// @notice Deposits and burns tokens from sender to be minted on destination domain.
// Emits a `DepositForBurn` event.
// @dev reverts if:
// - given burnToken is not supported
// - given destinationDomain has no TokenMessenger registered
// - transferFrom() reverts. For example, if sender's burnToken balance or approved allowance
// to this contract is less than `amount`.
// - burn() reverts. For example, if `amount` is 0.
// - MessageTransmitter returns false or reverts.
// @param axfer asset transfer of tokens to burn
// @param destinationDomain destination domain
// @param mintRecipient address of mint recipient on destination domain
// @param burnToken address of contract to burn deposited tokens, on local domain
// @return _nonce unique nonce reserved by message
depositForBurn:
	proto 4 1

	// src/TokenMessenger.algo.ts:343
	// return this._depositForBurn(
	// 			axfer,
	// 			destinationDomain,
	// 			mintRecipient,
	// 			burnToken,
	// 			// (zeroAddress here indicates that any address can call receiveMessage()
	// 			// on the destination domain, triggering mint to specified `mintRecipient`)
	// 			bzero(32) as StaticArray<byte, 32>
	// 		);
	byte 0x0000000000000000000000000000000000000000000000000000000000000000
	frame_dig -4 // burnToken: Asset
	frame_dig -3 // mintRecipient: bytes32
	frame_dig -2 // destinationDomain: uint<32>
	frame_dig -1 // axfer: AssetTransferTxn
	callsub _depositForBurn
	retsub

// depositForBurnWithCaller(axfer,uint32,byte[32],asset,byte[32])uint64
abi_route_depositForBurnWithCaller:
	// The ABI return prefix
	byte 0x151f7c75

	// destinationCaller: byte[32]
	txna ApplicationArgs 4
	dup
	len
	int 32
	==
	assert

	// burnToken: asset
	txna ApplicationArgs 3
	btoi
	txnas Assets

	// mintRecipient: byte[32]
	txna ApplicationArgs 2
	dup
	len
	int 32
	==
	assert

	// destinationDomain: uint32
	txna ApplicationArgs 1
	dup
	len
	int 4
	==
	assert
	btoi

	// axfer: axfer
	txn GroupIndex
	int 1
	-
	dup
	gtxns TypeEnum
	int axfer
	==
	assert

	// execute depositForBurnWithCaller(axfer,uint32,byte[32],asset,byte[32])uint64
	callsub depositForBurnWithCaller
	itob
	concat
	log
	int 1
	return

// depositForBurnWithCaller(axfer: AssetTransferTxn, destinationDomain: uint<32>, mintRecipient: bytes32, burnToken: Asset, destinationCaller: bytes32): uint<64>
//
// @notice Deposits and burns tokens from sender to be minted on destination domain. The mint
// on the destination domain must be called by `destinationCaller`.
// WARNING: if the `destinationCaller` does not represent a valid address as bytes32, then it will not be possible
// to broadcast the message on the destination domain. This is an advanced feature, and the standard
// depositForBurn() should be preferred for use cases where a specific destination caller is not required.
// Emits a `DepositForBurn` event.
// @dev reverts if:
// - given destinationCaller is zero address
// - given burnToken is not supported
// - given destinationDomain has no TokenMessenger registered
// - transferFrom() reverts. For example, if sender's burnToken balance or approved allowance
// to this contract is less than `amount`.
// - burn() reverts. For example, if `amount` is 0.
// - MessageTransmitter returns false or reverts.
// @param axfer amount of tokens to burn (must be non-zero)
// @param destinationDomain destination domain
// @param mintRecipient address of mint recipient on destination domain
// @param burnToken address of contract to burn deposited tokens, on local domain
// @param destinationCaller caller on the destination domain, as bytes32
// @return nonce unique nonce reserved by message
depositForBurnWithCaller:
	proto 5 1

	// src/TokenMessenger.algo.ts:384
	// assert(destinationCaller !== bzero(32) as bytes32)
	frame_dig -5 // destinationCaller: bytes32
	byte 0x0000000000000000000000000000000000000000000000000000000000000000
	!=
	assert

	// src/TokenMessenger.algo.ts:386
	// return this._depositForBurn(
	// 			axfer,
	// 			destinationDomain,
	// 			mintRecipient,
	// 			burnToken,
	// 			destinationCaller
	// 		);
	frame_dig -5 // destinationCaller: bytes32
	frame_dig -4 // burnToken: Asset
	frame_dig -3 // mintRecipient: bytes32
	frame_dig -2 // destinationDomain: uint<32>
	frame_dig -1 // axfer: AssetTransferTxn
	callsub _depositForBurn
	retsub

// replaceDepositForBurn(byte[],byte[],byte[32],byte[32])void
abi_route_replaceDepositForBurn:
	// newMintRecipient: byte[32]
	txna ApplicationArgs 4
	dup
	len
	int 32
	==
	assert

	// newDestinationCaller: byte[32]
	txna ApplicationArgs 3
	dup
	len
	int 32
	==
	assert

	// originalAttestation: byte[]
	txna ApplicationArgs 2
	extract 2 0

	// originalMessage: byte[]
	txna ApplicationArgs 1
	extract 2 0

	// execute replaceDepositForBurn(byte[],byte[],byte[32],byte[32])void
	callsub replaceDepositForBurn
	int 1
	return

// replaceDepositForBurn(originalMessage: bytes, originalAttestation: bytes, newDestinationCaller: bytes32, newMintRecipient: bytes32): void
//
// @notice Replace a BurnMessage to change the mint recipient and/or
// destination caller. Allows the sender of a previous BurnMessage
// (created by depositForBurn or depositForBurnWithCaller)
// to send a new BurnMessage to replace the original.
// The new BurnMessage will reuse the amount and burn token of the original,
// without requiring a new deposit.
// @dev The new message will reuse the original message's nonce. For a
// given nonce, all replacement message(s) and the original message are
// valid to broadcast on the destination domain, until the first message
// at the nonce confirms, at which point all others are invalidated.
// Note: The msg.sender of the replaced message must be the same as the
// msg.sender of the original message.
// @param originalMessage original message bytes (to replace)
// @param originalAttestation original attestation bytes
// @param newDestinationCaller the new destination caller, which may be the
// same as the original destination caller, a new destination caller, or an empty
// destination caller (bytes32(0), indicating that any destination caller is valid.)
// @param newMintRecipient the new mint recipient, which may be the same as the
// original mint recipient, or different.
replaceDepositForBurn:
	proto 4 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 6

	// src/TokenMessenger.algo.ts:422
	// msgLength = originalMessage.length
	frame_dig -1 // originalMessage: bytes
	len
	frame_bury 0 // msgLength: uint64

	// src/TokenMessenger.algo.ts:423
	// _originalMsg = castBytes<Message>(originalMessage)
	frame_dig -1 // originalMessage: bytes
	frame_bury 1 // _originalMsg: (uint32,uint32,uint32,uint64,byte[32],byte[32],byte[32])

	// src/TokenMessenger.algo.ts:424
	// _originalMsgBody = castBytes<BurnMessage>(substring3(originalMessage, 116, msgLength))
	frame_dig -1 // originalMessage: bytes
	int 116
	frame_dig 0 // msgLength: uint64
	substring3
	frame_bury 2 // _originalMsgBody: (uint32,byte[32],byte[32],uint256,byte[32])

	// src/TokenMessenger.algo.ts:428
	// assert(rawBytes(globals.callerApplicationAddress) as bytes32 === _originalMsgSender)
	global CallerApplicationAddress
	byte 0x0000000000000000000000000000000000000000000000000000000000000000
	concat
	dup
	extract 32 0
	byte 0x
	b==
	assert
	extract 0 32
	frame_dig 2 // _originalMsgBody: (uint32,byte[32],byte[32],uint256,byte[32])
	extract 100 32
	==
	assert

	// src/TokenMessenger.algo.ts:429
	// assert(newMintRecipient !== bzero(32) as bytes32)
	frame_dig -4 // newMintRecipient: bytes32
	byte 0x0000000000000000000000000000000000000000000000000000000000000000
	!=
	assert

	// src/TokenMessenger.algo.ts:431
	// _burnToken = Asset.fromID(btoi(_originalMsgBody._burnToken))
	frame_dig 2 // _originalMsgBody: (uint32,byte[32],byte[32],uint256,byte[32])
	extract 4 32
	btoi
	frame_bury 3 // _burnToken: asset

	// src/TokenMessenger.algo.ts:432
	// _amount = _originalMsgBody._amount
	frame_dig 2 // _originalMsgBody: (uint32,byte[32],byte[32],uint256,byte[32])
	extract 68 32
	frame_bury 4 // _amount: uint256

	// src/TokenMessenger.algo.ts:434
	// newMessageBody: BurnMessage = {
	// 			_version: this.messageBodyVersion.value,
	// 			_burnToken: itob(_burnToken) as bytes32,
	// 			_mintRecipient: newMintRecipient,
	// 			_amount: _amount,
	// 			_messageSender: _originalMsgSender
	// 		}
	byte 0x6d657373616765426f647956657273696f6e // "messageBodyVersion"
	app_global_get
	btoi
	itob
	extract 4 4
	frame_dig 3 // _burnToken: asset
	itob
	byte 0x0000000000000000000000000000000000000000000000000000000000000000
	concat
	dup
	extract 32 0
	byte 0x
	b==
	assert
	extract 0 32
	concat
	frame_dig -4 // newMintRecipient: bytes32
	concat
	frame_dig 4 // _amount: uint256
	concat
	frame_dig 2 // _originalMsgBody: (uint32,byte[32],byte[32],uint256,byte[32])
	extract 100 32
	concat
	frame_bury 5 // newMessageBody: BurnMessage

	// src/TokenMessenger.algo.ts:442
	// sendMethodCall<[bytes, bytes, bytes, bytes32], void>({
	// 			applicationID: this.localMessageTransmitter.value,
	// 			name: 'replaceMessage',
	// 			methodArgs: [
	// 				rawBytes(originalMessage),
	// 				originalAttestation,
	// 				rawBytes(newMessageBody),
	// 				newDestinationCaller
	// 			]
	// 		})
	itxn_begin
	int appl
	itxn_field TypeEnum
	method "replaceMessage(byte[],byte[],byte[],byte[32])void"
	itxn_field ApplicationArgs

	// src/TokenMessenger.algo.ts:443
	// applicationID: this.localMessageTransmitter.value
	byte 0x6c6f63616c4d6573736167655472616e736d6974746572 // "localMessageTransmitter"
	app_global_get
	itxn_field ApplicationID

	// src/TokenMessenger.algo.ts:445
	// methodArgs: [
	// 				rawBytes(originalMessage),
	// 				originalAttestation,
	// 				rawBytes(newMessageBody),
	// 				newDestinationCaller
	// 			]
	frame_dig -1 // originalMessage: bytes
	dup
	len
	itob
	extract 6 2
	swap
	concat
	dup
	len
	itob
	extract 6 2
	swap
	concat
	itxn_field ApplicationArgs
	frame_dig -2 // originalAttestation: bytes
	dup
	len
	itob
	extract 6 2
	swap
	concat
	itxn_field ApplicationArgs
	frame_dig 5 // newMessageBody: BurnMessage
	dup
	len
	itob
	extract 6 2
	swap
	concat
	itxn_field ApplicationArgs
	frame_dig -3 // newDestinationCaller: bytes32
	itxn_field ApplicationArgs

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// src/TokenMessenger.algo.ts:453
	// this.DepositForBurn.log({
	// 			nonce: _originalMsg._msgNonce,
	// 			burnToken: _burnToken,
	// 			amount: _amount,
	// 			depositor: this.txn.sender,
	// 			mintRecipient: newMintRecipient,
	// 			destinationDomain: _originalMsg._msgDestinationDomain,
	// 			destinationTokenMessenger: _originalMsg._msgRecipient,
	// 			destinationCaller: newDestinationCaller
	// 		})
	byte 0xd9074ca1 // DepositForBurn(uint64,uint64,uint256,address,byte[32],uint32,byte[32],byte[32])
	frame_dig 1 // _originalMsg: (uint32,uint32,uint32,uint64,byte[32],byte[32],byte[32])
	extract 12 8
	btoi
	itob
	frame_dig 3 // _burnToken: asset
	itob
	concat
	frame_dig 4 // _amount: uint256
	concat
	txn Sender
	concat
	frame_dig -4 // newMintRecipient: bytes32
	concat
	frame_dig 1 // _originalMsg: (uint32,uint32,uint32,uint64,byte[32],byte[32],byte[32])
	extract 8 4
	btoi
	itob
	extract 4 4
	concat
	frame_dig 1 // _originalMsg: (uint32,uint32,uint32,uint64,byte[32],byte[32],byte[32])
	extract 52 32
	concat
	frame_dig -3 // newDestinationCaller: bytes32
	concat
	concat
	log
	retsub

// handleReceiveMessage(uint32,byte[32],byte[])bool
abi_route_handleReceiveMessage:
	// The ABI return prefix
	byte 0x151f7c75

	// messageBody: byte[]
	txna ApplicationArgs 3
	extract 2 0

	// sender: byte[32]
	txna ApplicationArgs 2
	dup
	len
	int 32
	==
	assert

	// remoteDomain: uint32
	txna ApplicationArgs 1
	dup
	len
	int 4
	==
	assert
	btoi

	// execute handleReceiveMessage(uint32,byte[32],byte[])bool
	callsub handleReceiveMessage
	byte 0x00
	int 0
	uncover 2
	setbit
	concat
	log
	int 1
	return

// handleReceiveMessage(remoteDomain: uint<32>, sender: bytes32, messageBody: bytes): boolean
//
// @notice Handles an incoming message received by the local MessageTransmitter,
// and takes the appropriate action. For a burn message, mints the
// associated token to the requested recipient on the local domain.
// @dev Validates the local sender is the local MessageTransmitter, and the
// remote sender is a registered remote TokenMessenger for `remoteDomain`.
// @param remoteDomain The domain where the message originated from.
// @param sender The sender of the message (remote TokenMessenger).
// @param messageBody The message body bytes.
// @return success Bool, true if successful.
handleReceiveMessage:
	proto 3 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// src/TokenMessenger.algo.ts:481
	// this.onlyLocalMessageTransmitter()
	callsub onlyLocalMessageTransmitter

	// src/TokenMessenger.algo.ts:482
	// this.onlyRemoteTokenMessenger(remoteDomain, sender)
	frame_dig -2 // sender: bytes32
	frame_dig -1 // remoteDomain: uint<32>
	callsub onlyRemoteTokenMessenger

	// src/TokenMessenger.algo.ts:489
	// _messageBody = castBytes<BurnMessage>(messageBody)
	frame_dig -3 // messageBody: bytes
	frame_bury 0 // _messageBody: (uint32,byte[32],byte[32],uint256,byte[32])

	// src/TokenMessenger.algo.ts:491
	// assert(_messageBody._version === this.messageBodyVersion.value)
	frame_dig 0 // _messageBody: (uint32,byte[32],byte[32],uint256,byte[32])
	extract 0 4
	btoi
	byte 0x6d657373616765426f647956657273696f6e // "messageBodyVersion"
	app_global_get
	btoi
	==
	assert

	// src/TokenMessenger.algo.ts:495
	// this._mintAndWithdraw(
	// 			this._getLocalMinter(),
	// 			remoteDomain,
	// 			_messageBody._burnToken,
	// 			Address.fromBytes(_messageBody._mintRecipient),
	// 			extractUint64(rawBytes(_messageBody._amount), 24)
	// 		)
	frame_dig 0 // _messageBody: (uint32,byte[32],byte[32],uint256,byte[32])
	extract 68 32
	int 24
	extract_uint64
	frame_dig 0 // _messageBody: (uint32,byte[32],byte[32],uint256,byte[32])
	extract 36 32
	frame_dig 0 // _messageBody: (uint32,byte[32],byte[32],uint256,byte[32])
	extract 4 32
	frame_dig -1 // remoteDomain: uint<32>
	callsub _getLocalMinter
	callsub _mintAndWithdraw

	// src/TokenMessenger.algo.ts:503
	// return true;
	int 1

	// set the subroutine return value
	frame_bury 0
	retsub

// addRemoteTokenMessenger(uint32,byte[32])void
abi_route_addRemoteTokenMessenger:
	// tokenMessenger: byte[32]
	txna ApplicationArgs 2
	dup
	len
	int 32
	==
	assert

	// domain: uint32
	txna ApplicationArgs 1
	dup
	len
	int 4
	==
	assert
	btoi

	// execute addRemoteTokenMessenger(uint32,byte[32])void
	callsub addRemoteTokenMessenger
	int 1
	return

// addRemoteTokenMessenger(domain: uint<32>, tokenMessenger: bytes32): void
//
// @notice Add the TokenMessenger for a remote domain.
// @dev Reverts if there is already a TokenMessenger set for domain.
// @param domain Domain of remote TokenMessenger.
// @param tokenMessenger Address of remote TokenMessenger as bytes32.
addRemoteTokenMessenger:
	proto 2 0

	// src/TokenMessenger.algo.ts:516
	// this.onlyOwner()
	callsub onlyOwner

	// src/TokenMessenger.algo.ts:518
	// assert(tokenMessenger !== bzero(32) as bytes32)
	frame_dig -2 // tokenMessenger: bytes32
	byte 0x0000000000000000000000000000000000000000000000000000000000000000
	!=
	assert

	// src/TokenMessenger.algo.ts:519
	// assert(!this.remoteTokenMessengers(domain).exists)
	frame_dig -1 // domain: uint<32>
	itob
	extract 4 4
	box_len
	swap
	pop
	!
	assert

	// src/TokenMessenger.algo.ts:521
	// this.remoteTokenMessengers(domain).value = tokenMessenger
	frame_dig -1 // domain: uint<32>
	itob
	extract 4 4
	frame_dig -2 // tokenMessenger: bytes32
	box_put

	// src/TokenMessenger.algo.ts:523
	// this.RemoteTokenMessengerAdded.log({
	// 			domain: domain,
	// 			tokenMessenger: tokenMessenger
	// 		})
	byte 0x0e3304d0 // RemoteTokenMessengerAdded(uint32,byte[32])
	frame_dig -1 // domain: uint<32>
	itob
	extract 4 4
	frame_dig -2 // tokenMessenger: bytes32
	concat
	concat
	log
	retsub

// removeRemoteTokenMessenger(uint32)void
abi_route_removeRemoteTokenMessenger:
	// domain: uint32
	txna ApplicationArgs 1
	dup
	len
	int 4
	==
	assert
	btoi

	// execute removeRemoteTokenMessenger(uint32)void
	callsub removeRemoteTokenMessenger
	int 1
	return

// removeRemoteTokenMessenger(domain: uint<32>): void
//
// @notice Remove the TokenMessenger for a remote domain.
// @dev Reverts if there is no TokenMessenger set for `domain`.
// @param domain Domain of remote TokenMessenger
removeRemoteTokenMessenger:
	proto 1 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// src/TokenMessenger.algo.ts:537
	// this.onlyOwner()
	callsub onlyOwner

	// src/TokenMessenger.algo.ts:540
	// assert(this.remoteTokenMessengers(domain).exists)
	frame_dig -1 // domain: uint<32>
	itob
	extract 4 4
	box_len
	swap
	pop
	assert

	// src/TokenMessenger.algo.ts:542
	// _removedTokenMessenger = this.remoteTokenMessengers(domain).value
	frame_dig -1 // domain: uint<32>
	itob
	extract 4 4
	frame_bury 0 // storage key//_removedTokenMessenger

	// src/TokenMessenger.algo.ts:543
	// this.remoteTokenMessengers(domain).delete()
	frame_dig -1 // domain: uint<32>
	itob
	extract 4 4
	box_del

	// src/TokenMessenger.algo.ts:545
	// this.RemoteTokenMessengerRemoved.log({
	// 			domain: domain,
	// 			tokenMessenger: _removedTokenMessenger
	// 		})
	byte 0x15b31ebf // RemoteTokenMessengerRemoved(uint32,byte[32])
	frame_dig -1 // domain: uint<32>
	itob
	extract 4 4
	frame_dig 0 // storage key//_removedTokenMessenger
	box_get
	assert
	concat
	concat
	log
	retsub

// addLocalMinter(application)void
abi_route_addLocalMinter:
	// newLocalMinter: application
	txna ApplicationArgs 1
	btoi
	txnas Applications

	// execute addLocalMinter(application)void
	callsub addLocalMinter
	int 1
	return

// addLocalMinter(newLocalMinter: Application): void
//
// @notice Add minter for the local domain.
// @dev Reverts if a minter is already set for the local domain.
// @param newLocalMinter The address of the minter on the local domain.
addLocalMinter:
	proto 1 0

	// src/TokenMessenger.algo.ts:559
	// this.onlyOwner()
	callsub onlyOwner

	// src/TokenMessenger.algo.ts:561
	// assert(newLocalMinter)
	frame_dig -1 // newLocalMinter: Application
	assert

	// src/TokenMessenger.algo.ts:562
	// assert(!this.localMinter.exists)
	txna Applications 0
	byte 0x6c6f63616c4d696e746572 // "localMinter"
	app_global_get_ex
	swap
	pop
	!
	assert

	// src/TokenMessenger.algo.ts:564
	// this.localMinter.value = newLocalMinter
	byte 0x6c6f63616c4d696e746572 // "localMinter"
	frame_dig -1 // newLocalMinter: Application
	app_global_put

	// src/TokenMessenger.algo.ts:566
	// this.LocalMinterAdded.log({
	// 			localMinter: newLocalMinter
	// 		})
	byte 0x9f9e5c35 // LocalMinterAdded(uint64)
	frame_dig -1 // newLocalMinter: Application
	itob
	concat
	log
	retsub

// removeLocalMinter()void
abi_route_removeLocalMinter:
	// execute removeLocalMinter()void
	callsub removeLocalMinter
	int 1
	return

// removeLocalMinter(): void
//
// @notice Remove the minter for the local domain.
// @dev Reverts if the minter of the local domain is not set.
removeLocalMinter:
	proto 0 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// src/TokenMessenger.algo.ts:576
	// this.onlyOwner()
	callsub onlyOwner

	// src/TokenMessenger.algo.ts:578
	// _localMinterAddress: Application = this.localMinter.value
	byte 0x6c6f63616c4d696e746572 // "localMinter"
	app_global_get
	frame_bury 0 // _localMinterAddress: Application

	// src/TokenMessenger.algo.ts:579
	// assert(this.localMinter.exists)
	txna Applications 0
	byte 0x6c6f63616c4d696e746572 // "localMinter"
	app_global_get_ex
	swap
	pop
	assert

	// src/TokenMessenger.algo.ts:581
	// this.localMinter.delete()
	byte 0x6c6f63616c4d696e746572 // "localMinter"
	app_global_del

	// src/TokenMessenger.algo.ts:583
	// this.LocalMinterRemoved.log({
	// 			localMinter: _localMinterAddress
	// 		})
	byte 0xb8869e59 // LocalMinterRemoved(uint64)
	frame_dig 0 // _localMinterAddress: Application
	itob
	concat
	log
	retsub

// deploy(application,uint32)void
abi_route_deploy:
	// _messageBodyVersion: uint32
	txna ApplicationArgs 2
	dup
	len
	int 4
	==
	assert
	btoi

	// _messageTransmitter: application
	txna ApplicationArgs 1
	btoi
	txnas Applications

	// execute deploy(application,uint32)void
	callsub deploy
	int 1
	return

// deploy(_messageTransmitter: Application, _messageBodyVersion: uint<32>): void
//
// @param _messageTransmitter Message transmitter address
// @param _messageBodyVersion Message body version
deploy:
	proto 2 0

	// src/TokenMessenger.algo.ts:599
	// assert(_messageTransmitter)
	frame_dig -1 // _messageTransmitter: Application
	assert

	// src/TokenMessenger.algo.ts:602
	// this._transferOwnership(this.txn.sender)
	txn Sender
	callsub _transferOwnership

	// src/TokenMessenger.algo.ts:604
	// this.localMessageTransmitter.value = _messageTransmitter
	byte 0x6c6f63616c4d6573736167655472616e736d6974746572 // "localMessageTransmitter"
	frame_dig -1 // _messageTransmitter: Application
	app_global_put

	// src/TokenMessenger.algo.ts:605
	// this.messageBodyVersion.value = _messageBodyVersion
	byte 0x6d657373616765426f647956657273696f6e // "messageBodyVersion"
	frame_dig -2 // _messageBodyVersion: uint<32>
	itob
	extract 4 4
	app_global_put
	retsub

create_NoOp:
	method "deploy(application,uint32)void"
	txna ApplicationArgs 0
	match abi_route_deploy
	err

call_NoOp:
	method "owner()address"
	method "_checkOwner()void"
	method "transferOwnership(address)void"
	method "pendingOwner()address"
	method "transferOwnership2S(address)void"
	method "acceptOwnership()void"
	method "depositForBurn(axfer,uint32,byte[32],asset)uint64"
	method "depositForBurnWithCaller(axfer,uint32,byte[32],asset,byte[32])uint64"
	method "replaceDepositForBurn(byte[],byte[],byte[32],byte[32])void"
	method "handleReceiveMessage(uint32,byte[32],byte[])bool"
	method "addRemoteTokenMessenger(uint32,byte[32])void"
	method "removeRemoteTokenMessenger(uint32)void"
	method "addLocalMinter(application)void"
	method "removeLocalMinter()void"
	txna ApplicationArgs 0
	match abi_route_owner abi_route__checkOwner abi_route_transferOwnership abi_route_pendingOwner abi_route_transferOwnership2S abi_route_acceptOwnership abi_route_depositForBurn abi_route_depositForBurnWithCaller abi_route_replaceDepositForBurn abi_route_handleReceiveMessage abi_route_addRemoteTokenMessenger abi_route_removeRemoteTokenMessenger abi_route_addLocalMinter abi_route_removeLocalMinter
	err